<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Prophet - Prediction Markets on Lightning</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      background: #0a0a0a;
      color: #e0e0e0;
      line-height: 1.6;
    }
    h1, h2, h3 {
      color: #fff;
    }
    a {
      color: #7cb3ff;
    }
    button {
      background: #2563eb;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      width: 100%;
      margin: 8px 0;
    }
    button:hover {
      background: #1d4ed8;
    }
    button:disabled {
      background: #444;
      cursor: not-allowed;
    }
    button.secondary {
      background: #333;
    }
    button.secondary:hover {
      background: #444;
    }
    button.yes {
      background: #16a34a;
    }
    button.yes:hover {
      background: #15803d;
    }
    button.no {
      background: #dc2626;
    }
    button.no:hover {
      background: #b91c1c;
    }
    input, textarea {
      width: 100%;
      padding: 12px;
      margin: 8px 0;
      border: 1px solid #333;
      border-radius: 6px;
      background: #1a1a1a;
      color: #e0e0e0;
      font-size: 16px;
    }
    input:focus, textarea:focus {
      outline: none;
      border-color: #2563eb;
    }
    label {
      display: block;
      margin-top: 16px;
      font-weight: 500;
    }
    .view {
      display: none;
    }
    .view.active {
      display: block;
    }
    .card {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 20px;
      margin: 16px 0;
    }
    .odds {
      display: flex;
      gap: 16px;
      margin: 16px 0;
    }
    .odds > div {
      flex: 1;
      text-align: center;
      padding: 16px;
      border-radius: 8px;
      background: #222;
    }
    .odds .outcome {
      font-size: 14px;
      color: #888;
      margin-bottom: 4px;
    }
    .odds .pool {
      font-size: 24px;
      font-weight: bold;
    }
    .status {
      padding: 12px;
      border-radius: 6px;
      margin: 16px 0;
    }
    .status.info {
      background: #1e3a5f;
      border: 1px solid #2563eb;
    }
    .status.success {
      background: #14532d;
      border: 1px solid #16a34a;
    }
    .status.warning {
      background: #422006;
      border: 1px solid #d97706;
    }
    .qr-container {
      text-align: center;
      padding: 20px;
      background: white;
      border-radius: 8px;
      margin: 16px 0;
    }
    .qr-container img, .qr-container canvas {
      max-width: 100%;
      width: 200px;
      height: auto;
    }
    .invoice-text {
      font-family: monospace;
      font-size: 12px;
      word-break: break-all;
      background: #111;
      padding: 12px;
      border-radius: 6px;
      margin: 8px 0;
    }
    .nsec-warning {
      background: #422006;
      border: 1px solid #d97706;
      padding: 16px;
      border-radius: 8px;
      margin: 16px 0;
    }
    .nsec-display {
      font-family: monospace;
      background: #111;
      padding: 12px;
      border-radius: 6px;
      word-break: break-all;
      margin: 8px 0;
    }
    .bet-list {
      margin: 16px 0;
    }
    .bet-item {
      display: flex;
      justify-content: space-between;
      padding: 8px;
      border-bottom: 1px solid #333;
    }
    .bet-item:last-child {
      border-bottom: none;
    }
    .hidden {
      display: none;
    }
    .loader {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid #333;
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    footer {
      margin-top: 40px;
      padding-top: 20px;
      border-top: 1px solid #333;
      text-align: center;
      color: #666;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <!-- Update banner (hidden by default) -->
  <div id="update-banner" style="display: none; background: linear-gradient(135deg, #1e40af, #7c3aed); padding: 10px 16px; text-align: center; cursor: pointer; font-size: 14px;" onclick="location.reload()">
    ðŸ”® New version available! <strong>Click to refresh</strong>
  </div>

  <!-- Header with logo -->
  <header style="padding: 12px 0; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;">
    <div onclick="showView('home-view')" style="cursor: pointer; display: flex; align-items: center; gap: 8px;" role="button" aria-label="Go to home" tabindex="0">
      <div style="font-size: 24px; line-height: 1;" aria-hidden="true">ðŸ”®</div>
      <span style="font-size: 18px; font-weight: 600; color: #fff;">Prophet</span>
    </div>
    <div onclick="showView('creator-view')" style="cursor: pointer; padding: 8px; border-radius: 6px; background: #222; display: flex; align-items: center; justify-content: center;" title="Creator Dashboard" role="button" aria-label="Creator Dashboard" tabindex="0">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#888" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <circle cx="12" cy="8" r="5"></circle>
        <path d="M3 21v-2a7 7 0 0 1 7-7h4a7 7 0 0 1 7 7v2"></path>
      </svg>
    </div>
  </header>

  <!-- Loading View (for URL params) -->
  <div id="loading-view" class="view">
    <div style="text-align: center; padding: 60px 20px;">
      <div class="loader" style="margin: 0 auto;"></div>
      <p style="margin-top: 20px; color: #888;">Fetching prophecy from Nostr relays...</p>
    </div>
  </div>

  <!-- Home View -->
  <div id="home-view" class="view active">
    <p style="font-size: 20px; margin: 24px 0; line-height: 1.4; text-align: center;">Create a prediction market for anything.<br>Real money. Real stakes.</p>

    <button id="btn-create-view">Create a Prophecy</button>

    <div class="card">
      <h3 style="margin-top: 0;">How it works</h3>
      <p style="margin-bottom: 12px;">Ask a yes/no question, share the link with your crew, and let them put bitcoin on their predictions. When you resolve it, winners get paid automatically. You keep 5%.</p>
      <p style="margin-bottom: 0; color: #888; font-size: 14px;">No signup. No install. Just a link.</p>
    </div>
  </div>

  <!-- Create Market View -->
  <div id="create-view" class="view">
    <h2>Create a Prophecy</h2>

    <div id="create-step-1">
      <label for="nwc-input">NWC Connection String</label>
      <input type="text" id="nwc-input" placeholder="nostr+walletconnect://..." autocomplete="off" />
      <p style="color: #888; font-size: 14px;">Get this from <a href="https://primal.net/downloads" target="_blank">Primal</a>: Settings â†’ Wallet â†’ Create new wallet connection</p>

      <label for="question-input">Question</label>
      <input type="text" id="question-input" placeholder="Will X happen by Y date?" />

      <label for="resolution-date-input">Resolution Date</label>
      <input type="datetime-local" id="resolution-date-input" />

      <label for="yes-criteria-input">YES wins if...</label>
      <input type="text" id="yes-criteria-input" placeholder="Steve shaves his beard by end of month" />

      <label for="no-criteria-input">NO wins if...</label>
      <input type="text" id="no-criteria-input" placeholder="The beard survives" />

      <label for="max-bet-input">Max Bet (â‚¿, optional)</label>
      <input type="number" id="max-bet-input" placeholder="10000" />

      <button id="btn-create-market">Create Prophecy</button>
      <div id="create-status" class="hidden" style="text-align: center; padding: 20px;" role="status" aria-live="polite">
        <div class="loader" aria-hidden="true"></div>
        <p id="create-status-text" style="margin-top: 12px; color: #888;">Publishing to Nostr relays...</p>
      </div>
      <button id="btn-cancel-create" class="secondary">Cancel</button>
    </div>

    <div id="create-step-2" class="hidden">
      <div class="status success">Prophecy created!</div>

      <div id="market-summary" style="background: #1a1a2e; border-radius: 8px; padding: 16px; margin-bottom: 20px;">
        <h3 id="summary-question" style="margin: 0 0 12px 0; color: #fff;"></h3>
        <p id="summary-details" style="margin: 0; color: #888; font-size: 14px;"></p>
      </div>

      <div class="nsec-warning">
        <strong>Save this secret key!</strong>
        <p>You need it to resolve the prophecy later. Store it securely.</p>
        <div class="nsec-display" id="nsec-display"></div>
        <button onclick="copyNsec()">Copy to Clipboard</button>
      </div>

      <label>Share this link:</label>
      <input type="text" id="share-url" readonly />
      <button onclick="copyShareUrl()">Copy Link</button>
      <button class="secondary" onclick="goToMarket()">Go to Prophecy</button>
    </div>
  </div>

  <!-- Market View (Betting) -->
  <div id="market-view" class="view">
    <h2 id="market-question">Loading...</h2>

    <div class="card">
      <p style="margin: 0;"><strong>Resolves:</strong> <span id="market-resolution-date"></span></p>
    </div>

    <div class="odds">
      <div>
        <div class="outcome">YES</div>
        <div class="pool" id="yes-pool">â‚¿0</div>
      </div>
      <div>
        <div class="outcome">NO</div>
        <div class="pool" id="no-pool">â‚¿0</div>
      </div>
    </div>

    <div id="betting-open">
      <div id="bet-form">
        <label for="payout-address-input">Your Lightning Address *</label>
        <input type="text" id="payout-address-input" placeholder="you@walletofsatoshi.com" required autocomplete="email" />
        <p style="font-size: 12px; color: #888; margin: 4px 0 12px 0;">Where to send your winnings if you win.</p>

        <label for="bet-amount-input">Bet Amount (â‚¿)</label>
        <input type="number" id="bet-amount-input" placeholder="500" oninput="updatePotentialWinnings()" />

        <div id="potential-winnings" style="background: #1a1a2e; border-radius: 8px; padding: 12px; margin: 12px 0; font-size: 14px;">
          <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
            <span>If <strong style="color: #4ade80;">YES</strong> wins:</span>
            <span id="yes-potential">Enter amount above</span>
          </div>
          <div style="display: flex; justify-content: space-between;">
            <span>If <strong style="color: #f87171;">NO</strong> wins:</span>
            <span id="no-potential">Enter amount above</span>
          </div>
        </div>

        <div id="bet-error" class="hidden" style="background: #450a0a; border: 1px solid #dc2626; padding: 10px 12px; border-radius: 6px; margin-bottom: 12px; font-size: 14px; color: #fca5a5;"></div>

        <div style="display: flex; flex-direction: column; gap: 12px;">
          <div style="background: #0d2818; border: 1px solid #16a34a; border-radius: 8px; padding: 12px;">
            <p id="yes-criteria-display" style="margin: 0 0 10px 0; font-size: 14px; color: #a8e6a0;"></p>
            <button class="yes" onclick="placeBet('yes')" style="margin: 0;">Bet YES</button>
          </div>
          <div style="background: #2a1215; border: 1px solid #dc2626; border-radius: 8px; padding: 12px;">
            <p id="no-criteria-display" style="margin: 0 0 10px 0; font-size: 14px; color: #f8a0a0;"></p>
            <button class="no" onclick="placeBet('no')" style="margin: 0;">Bet NO</button>
          </div>
        </div>
      </div>

      <div id="bet-invoice" class="hidden">
        <div class="status info">Pay this invoice to confirm your bet:</div>
        <p style="text-align: center; color: #888; margin-bottom: 12px;">Scan with your Lightning wallet</p>
        <div class="qr-container" id="qr-container">
        </div>

        <div id="auto-verify-section" style="margin-top: 16px; padding: 16px; background: #1a2a1a; border: 1px solid #4a4; border-radius: 8px; text-align: center;" role="status" aria-live="polite">
          <p id="payment-status" style="color: #6c6; margin: 0 0 8px 0; font-weight: bold; font-size: 15px;">Waiting for payment...</p>
          <p style="color: #888; margin: 0; font-size: 13px;">Payment will be verified automatically</p>
        </div>

        <details style="margin-top: 16px;">
          <summary style="cursor: pointer; color: #666; font-size: 13px;">Other payment options</summary>
          <div style="margin-top: 12px;">
            <div class="invoice-text" id="invoice-text" style="font-size: 11px; margin-bottom: 12px;"></div>
            <button onclick="copyInvoice()" style="margin-bottom: 8px;">Copy Invoice</button>
            <div id="webln-pay-section">
              <button id="btn-webln-pay" onclick="payWithWebLN()">Pay with Browser Wallet</button>
              <p style="color: #666; font-size: 12px; margin-top: 4px;">For Alby and other WebLN wallets</p>
            </div>
          </div>
        </details>

        <div style="margin-top: 16px;">
          <button class="secondary" onclick="cancelBet()">Cancel (I haven't paid)</button>
        </div>
      </div>

      <div id="bet-confirmed" class="hidden">
        <div class="status success">Bet confirmed!</div>
        <div style="background: #1a1a2e; border-radius: 8px; padding: 16px; margin: 12px 0;">
          <p style="margin: 0 0 8px 0;"><strong id="confirmed-outcome" style="font-size: 18px;"></strong> for <strong id="confirmed-amount"></strong></p>
          <p style="margin: 0; color: #888; font-size: 14px;">Potential win: <span id="confirmed-payout" style="color: #4ade80;"></span></p>
        </div>
        <p style="color: #888; font-size: 14px;">If you win, payment will be sent to your Lightning Address.</p>
        <button onclick="resetBetForm()">Place Another Bet</button>
      </div>

    </div>

    <div id="betting-closed" class="hidden">
      <div class="status warning">Betting is closed. Awaiting revelation.</div>
    </div>

    <div id="market-resolved" class="hidden">
      <div class="status success">
        <strong>Resolved:</strong> <span id="resolved-outcome"></span> won!
      </div>
    </div>

    <div class="card">
      <h3>Recent Bets</h3>
      <div id="bet-list" class="bet-list">
        <p style="color: #888; text-align: center; padding: 8px 0;">Be the first to bet!</p>
      </div>
    </div>

  </div>

  <!-- Creator Dashboard View -->
  <div id="creator-view" class="view">
    <h2>Creator Dashboard</h2>

    <div id="creator-login">
      <p style="color: #aaa; margin-bottom: 16px;">Enter your nsec to view and manage your prophecies.</p>
      <label for="creator-nsec-input">Your nsec (secret key)</label>
      <input type="password" id="creator-nsec-input" placeholder="nsec1..." autocomplete="off" />
      <button onclick="creatorLogin()">Login</button>
    </div>

    <div id="creator-dashboard" class="hidden">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
        <p style="color: #888; margin: 0;">Logged in as: <span id="creator-pubkey" style="color: #4ade80; font-family: monospace;"></span></p>
        <button class="secondary" onclick="creatorLogout()" style="padding: 6px 12px; font-size: 12px;">Logout</button>
      </div>

      <h3>Your Prophecies</h3>
      <div id="creator-markets-list">
        <p style="color: #666;">Loading...</p>
      </div>
    </div>
  </div>

  <!-- Resolve View -->
  <div id="resolve-view" class="view">
    <h2>Resolve Prophecy</h2>
    <p id="resolve-question"></p>

    <label for="resolve-nsec-input">Your nsec (secret key)</label>
    <input type="password" id="resolve-nsec-input" placeholder="nsec1..." autocomplete="off" />

    <div id="resolve-form">
      <p>Select the winning outcome:</p>
      <button class="yes" onclick="resolveMarket('yes')">YES Won</button>
      <button class="no" onclick="resolveMarket('no')">NO Won</button>
    </div>

    <div id="payout-section" class="hidden">
      <div class="status success">Prophecy resolved!</div>
      <h3>Payouts</h3>
      <div id="payout-list"></div>
      <button id="btn-pay-winners" onclick="payAllWinners()">Pay All Winners</button>
      <div id="payout-status"></div>
    </div>

    <button class="secondary" onclick="showView('creator-view')">Back to Dashboard</button>
  </div>

  <footer>
    <p>Prophet - Powered by Nostr + Lightning</p>
    <p style="font-size: 11px; color: #444; margin-top: 12px;" id="version">v62</p>
  </footer>

  <!-- Scripts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script type="module">
    // ============================================
    // IMPORTS
    // ============================================
    import { generateSecretKey, getPublicKey, finalizeEvent, verifyEvent } from 'https://esm.sh/nostr-tools@2.10.4';
    import { nsecEncode, npubEncode, noteEncode, decode as nip19Decode } from 'https://esm.sh/nostr-tools@2.10.4/nip19';
    import { Relay } from 'https://esm.sh/nostr-tools@2.10.4/relay';
    import { encrypt as nip04Encrypt, decrypt as nip04Decrypt } from 'https://esm.sh/nostr-tools@2.10.4/nip04';

    // ============================================
    // GLOBALS
    // ============================================
    const DEBUG = false; // Set to true for verbose logging
    const RELAYS = [
      'wss://relay.damus.io',
      'wss://relay.primal.net'
    ];
    const FEE_PERCENT = 5;

    function debug(...args) {
      if (DEBUG) console.log(...args);
    }

    // Global state
    let relayConnections = [];
    let currentMarket = null;
    let currentBets = [];
    let currentResolution = null;
    let creatorNsec = null;
    let creatorNwcString = null;
    let pendingInvoice = null;

    // ============================================
    // VIEW MANAGEMENT
    // ============================================
    function showView(viewId) {
      document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
      document.getElementById(viewId).classList.add('active');
    }
    window.showView = showView;

    // ============================================
    // NOSTR UTILITIES
    // ============================================
    function generateKeypair() {
      const sk = generateSecretKey();
      const pk = getPublicKey(sk);
      const nsec = nsecEncode(sk);
      const npub = npubEncode(pk);
      return { sk, pk, nsec, npub };
    }

    function decodeNsec(nsec) {
      try {
        const { type, data } = nip19Decode(nsec);
        if (type === 'nsec') return data;
      } catch (e) {
        console.error('Failed to decode nsec:', e);
      }
      return null;
    }

    function decodeNoteId(noteId) {
      try {
        if (noteId.startsWith('note1')) {
          const { type, data } = nip19Decode(noteId);
          if (type === 'note') return data;
        }
        // Assume hex
        if (/^[0-9a-f]{64}$/i.test(noteId)) return noteId;
      } catch (e) {
        console.error('Failed to decode note ID:', e);
      }
      return null;
    }

    async function connectRelays() {
      relayConnections = [];
      for (const url of RELAYS) {
        try {
          debug('Connecting to', url);
          const relay = await Relay.connect(url);
          relayConnections.push(relay);
          debug('Connected to', url);
        } catch (e) {
          console.error('Failed to connect to', url, e);
        }
      }
      debug('Connected to', relayConnections.length, 'relays');
      return relayConnections.length > 0;
    }

    async function publishEvent(event) {
      let published = false;
      for (const relay of relayConnections) {
        try {
          await relay.publish(event);
          published = true;
          debug('Published to', relay.url);
        } catch (e) {
          console.error('Failed to publish to', relay.url, e);
        }
      }
      return published;
    }

    async function fetchEvents(filter) {
      const events = [];
      const seen = new Set();

      debug('Fetching events with filter:', filter);
      debug('Relay connections:', relayConnections.length);

      // Reconnect if needed
      const activeRelays = relayConnections.filter(r => r.connected);
      debug('Active relays:', activeRelays.length);

      if (activeRelays.length === 0) {
        debug('No active relays, reconnecting...');
        relayConnections = [];
        await connectRelays();
      }

      for (const relay of relayConnections) {
        if (!relay.connected) {
          debug('Skipping disconnected relay:', relay.url);
          continue;
        }
        try {
          debug('Subscribing to', relay.url);
          const sub = relay.subscribe([filter], {
            onevent(event) {
              debug('Got event from', relay.url, event.id);
              if (!seen.has(event.id)) {
                seen.add(event.id);
                events.push(event);
              }
            }
          });
          // Wait a bit for events to come in
          await new Promise(r => setTimeout(r, 3000));
          sub.close();
        } catch (e) {
          console.error('Failed to fetch from', relay.url, e);
        }
      }
      debug('Total events found:', events.length);
      return events;
    }

    // ============================================
    // NWC UTILITIES
    // ============================================
    function parseNwcString(nwcString) {
      try {
        // Format: nostr+walletconnect://<pubkey>?relay=<relay>&secret=<secret>
        const url = new URL(nwcString.replace('nostr+walletconnect://', 'https://'));
        const pubkey = url.hostname || url.pathname.replace('//', '');
        const relay = url.searchParams.get('relay');
        const secret = url.searchParams.get('secret');
        return { pubkey, relay, secret };
      } catch (e) {
        console.error('Failed to parse NWC string', e);
        return null;
      }
    }

    // Cached NWC relay connection
    let nwcRelay = null;
    let nwcRelayConnecting = false;

    async function getNwcRelay() {
      const nwc = parseNwcString(creatorNwcString);
      if (!nwc) throw new Error('Invalid NWC connection');

      // Return existing connection if valid
      if (nwcRelay && nwcRelay.connected) {
        return nwcRelay;
      }

      // Wait if already connecting
      if (nwcRelayConnecting) {
        await new Promise(r => setTimeout(r, 500));
        return getNwcRelay();
      }

      // Create new connection
      nwcRelayConnecting = true;
      try {
        debug('Connecting to NWC relay:', nwc.relay);
        nwcRelay = await Relay.connect(nwc.relay);
        debug('Connected to NWC relay');
        return nwcRelay;
      } finally {
        nwcRelayConnecting = false;
      }
    }

    function closeNwcRelay() {
      if (nwcRelay) {
        try { nwcRelay.close(); } catch (e) {}
        nwcRelay = null;
      }
    }

    async function nwcRequest(method, params = {}) {
      debug('NWC request:', method, params);
      const nwc = parseNwcString(creatorNwcString);
      if (!nwc) throw new Error('Invalid NWC connection');

      // NWC secret is hex-encoded
      const secretKey = hexToBytes(nwc.secret);

      // Get or create relay connection
      const relay = await getNwcRelay();

      // Create request
      const request = {
        method,
        params
      };

      const content = await nip04Encrypt(secretKey, nwc.pubkey, JSON.stringify(request));

      const event = {
        kind: 23194,
        created_at: Math.floor(Date.now() / 1000),
        tags: [['p', nwc.pubkey]],
        content
      };

      const signedEvent = finalizeEvent(event, secretKey);

      // IMPORTANT: Subscribe for response BEFORE publishing request
      // Response events are ephemeral, so we must be listening before they're sent
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          sub.close();
          reject(new Error('NWC request timeout'));
        }, 30000);

        const filter = {
          kinds: [23195],
          '#e': [signedEvent.id],
          '#p': [signedEvent.pubkey],
          since: Math.floor(Date.now() / 1000) - 10
        };
        const subId = `deekay-pm-${signedEvent.id.slice(0, 8)}`;
        debug('NWC subscribing with filter:', JSON.stringify(filter, null, 2));
        debug('Our pubkey (from signed event):', signedEvent.pubkey);
        debug('Request event ID:', signedEvent.id);
        debug('Subscription ID:', subId);

        const sub = relay.subscribe([filter], {
          id: subId,
          async onevent(event) {
            debug('=== Got NWC response event ===');
            try {
              const decrypted = await nip04Decrypt(secretKey, nwc.pubkey, event.content);
              const response = JSON.parse(decrypted);
              clearTimeout(timeout);
              sub.close();
              // Don't close relay - keep it for future requests
              if (response.error) {
                reject(new Error(response.error.message || 'NWC error'));
              } else {
                resolve(response.result);
              }
            } catch (e) {
              reject(e);
            }
          },
          oneose() {
            debug('NWC subscription EOSE - now publishing request');
            // Publish request AFTER subscription is established and EOSE received
            relay.publish(signedEvent).then(() => {
              debug('Request published:', signedEvent.id);
            }).catch(e => {
              console.error('Failed to publish request:', e);
              clearTimeout(timeout);
              sub.close();
              reject(e);
            });
          }
        });
      });
    }

    function hexToBytes(hex) {
      const bytes = new Uint8Array(hex.length / 2);
      for (let i = 0; i < hex.length; i += 2) {
        bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
      }
      return bytes;
    }

    function bytesToHex(bytes) {
      return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // ============================================
    // CREATE MARKET
    // ============================================
    function setCreateStatus(show, text = 'Publishing to Nostr relays...') {
      const btn = document.getElementById('btn-create-market');
      const status = document.getElementById('create-status');
      const statusText = document.getElementById('create-status-text');
      if (show) {
        btn.classList.add('hidden');
        status.classList.remove('hidden');
        statusText.textContent = text;
      } else {
        btn.classList.remove('hidden');
        status.classList.add('hidden');
      }
    }

    async function createMarket() {
      debug('Creating market...');
      try {

      const nwcString = document.getElementById('nwc-input').value.trim();
      const question = document.getElementById('question-input').value.trim();
      const resolutionDate = document.getElementById('resolution-date-input').value;
      const yesCriteria = document.getElementById('yes-criteria-input').value.trim();
      const noCriteria = document.getElementById('no-criteria-input').value.trim();
      const maxBet = document.getElementById('max-bet-input').value;

      if (!nwcString || !question || !resolutionDate || !yesCriteria || !noCriteria) {
        alert('Please fill in all required fields');
        return;
      }

      setCreateStatus(true, 'Connecting to relays...');
      creatorNwcString = nwcString;

      // Generate keypair for this market
      debug('Generating keypair...');
      const keypair = generateKeypair();
      creatorNsec = keypair.nsec;
      debug('Keypair generated:', keypair.npub);

      // Connect to relays
      if (relayConnections.length === 0) {
        debug('Connecting to relays...');
        const connected = await connectRelays();
        if (!connected) {
          setCreateStatus(false);
          alert('Failed to connect to relays');
          return;
        }
      }
      setCreateStatus(true, 'Publishing to Nostr relays...');

      // Create market event
      const marketContent = {
        type: 'market',
        question,
        resolution_date: new Date(resolutionDate).toISOString(),
        yes_criteria: yesCriteria,
        no_criteria: noCriteria,
        nwc_connection: nwcString  // Store NWC so any bettor can generate invoices
      };
      if (maxBet) {
        marketContent.max_bet_sats = parseInt(maxBet);
      }

      const event = {
        kind: 1,
        created_at: Math.floor(Date.now() / 1000),
        tags: [
          ['t', 'prediction-market'],
          ['t', 'pm-market']
        ],
        content: JSON.stringify(marketContent)
      };

      debug('Signing event...');
      const signedEvent = finalizeEvent(event, keypair.sk);
      debug('Event signed:', signedEvent.id);

      debug('Publishing event...');
      const published = await publishEvent(signedEvent);
      if (!published) {
        setCreateStatus(false);
        alert('Failed to publish prophecy');
        return;
      }
      debug('Event published!');
      setCreateStatus(false);

      // Store NWC and SK in localStorage for this market
      localStorage.setItem(`nwc_${signedEvent.id}`, nwcString);
      localStorage.setItem(`sk_${signedEvent.id}`, bytesToHex(keypair.sk));

      // Show success
      document.getElementById('nsec-display').textContent = keypair.nsec;
      document.getElementById('share-url').value = `${window.location.origin}${window.location.pathname}?m=${noteEncode(signedEvent.id)}`;

      // Show market summary
      document.getElementById('summary-question').textContent = marketContent.question;
      const resDate = new Date(marketContent.resolution_date).toLocaleDateString();
      let details = `Resolves: ${resDate}`;
      if (marketContent.max_bet_sats) {
        details += ` Â· Max bet: â‚¿${marketContent.max_bet_sats.toLocaleString()}`;
      }
      document.getElementById('summary-details').textContent = details;

      document.getElementById('create-step-1').classList.add('hidden');
      document.getElementById('create-step-2').classList.remove('hidden');

      currentMarket = {
        id: signedEvent.id,
        pubkey: keypair.pk,
        content: marketContent,
        event: signedEvent
      };

      } catch (e) {
        console.error('Error creating market:', e);
        setCreateStatus(false);
        alert('Error creating prophecy: ' + e.message);
      }
    }
    window.createMarket = createMarket;

    function copyNsec() {
      navigator.clipboard.writeText(document.getElementById('nsec-display').textContent);
      alert('Copied!');
    }
    window.copyNsec = copyNsec;

    function copyShareUrl() {
      navigator.clipboard.writeText(document.getElementById('share-url').value);
      alert('Copied!');
    }
    window.copyShareUrl = copyShareUrl;

    function goToMarket() {
      window.location.href = document.getElementById('share-url').value;
    }
    window.goToMarket = goToMarket;

    // ============================================
    // LOAD MARKET
    // ============================================
    async function loadMarketById(marketId) {
      // If it's already a hex event ID (64 chars), use it directly
      const eventId = marketId.length === 64 && /^[a-f0-9]+$/.test(marketId) ? marketId : decodeNoteId(marketId);
      if (!eventId) {
        alert('Invalid prophecy ID');
        return;
      }
      await loadMarket(eventId);
    }
    window.loadMarketById = loadMarketById;

    async function loadMarket(eventId) {
      debug('Loading market:', eventId);

      // Connect to relays
      if (relayConnections.length === 0) {
        const connected = await connectRelays();
        if (!connected) {
          alert('Failed to connect to relays');
          return;
        }
      }

      // Fetch market event
      const marketEvents = await fetchEvents({
        ids: [eventId],
        kinds: [1]
      });

      debug('Market events found:', marketEvents.length);

      if (marketEvents.length === 0) {
        alert('Prophecy not found. Check console for details.');
        return;
      }

      const marketEvent = marketEvents[0];
      let content;
      try {
        content = JSON.parse(marketEvent.content);
        if (content.type !== 'market') throw new Error('Not a market event');
      } catch (e) {
        alert('Invalid prophecy event');
        return;
      }

      currentMarket = {
        id: eventId,
        pubkey: marketEvent.pubkey,
        content,
        event: marketEvent
      };

      // Load NWC from market event (for any bettor) or localStorage (backwards compat)
      if (content.nwc_connection) {
        creatorNwcString = content.nwc_connection;
      } else {
        // Fallback to localStorage for older markets
        const storedNwc = localStorage.getItem(`nwc_${eventId}`);
        if (storedNwc) {
          creatorNwcString = storedNwc;
        }
      }

      // Fetch bets
      const betEvents = await fetchEvents({
        kinds: [1],
        '#t': ['pm-bet'],
        '#e': [eventId]
      });

      currentBets = betEvents.map(e => {
        try {
          return { ...JSON.parse(e.content), id: e.id, created_at: e.created_at };
        } catch {
          return null;
        }
      }).filter(b => b && b.type === 'bet');

      // Fetch resolution
      const resolutionEvents = await fetchEvents({
        kinds: [1],
        '#t': ['pm-resolution'],
        '#e': [eventId]
      });

      currentResolution = null;
      for (const e of resolutionEvents) {
        try {
          const r = JSON.parse(e.content);
          if (r.type === 'resolution' && e.pubkey === marketEvent.pubkey) {
            currentResolution = r;
            break;
          }
        } catch {}
      }

      renderMarket();
      showView('market-view');
    }

    function renderMarket() {
      if (!currentMarket) return;

      const c = currentMarket.content;
      document.getElementById('market-question').textContent = c.question;
      document.getElementById('market-resolution-date').textContent = new Date(c.resolution_date).toLocaleString();
      document.getElementById('resolve-question').textContent = c.question;

      // Display criteria (handle both new and old format)
      if (c.yes_criteria && c.no_criteria) {
        document.getElementById('yes-criteria-display').textContent = c.yes_criteria;
        document.getElementById('no-criteria-display').textContent = c.no_criteria;
      } else if (c.resolution_criteria) {
        // Old format - show same text for both
        document.getElementById('yes-criteria-display').textContent = c.resolution_criteria;
        document.getElementById('no-criteria-display').textContent = c.resolution_criteria;
      }

      // Pre-fill saved Lightning Address
      const savedAddress = localStorage.getItem('lightning_address');
      const addressInput = document.getElementById('payout-address-input');
      if (savedAddress && !addressInput.value) {
        addressInput.value = savedAddress;
      }

      // Calculate pools
      let yesPool = 0;
      let noPool = 0;
      for (const bet of currentBets) {
        if (bet.outcome === 'yes') yesPool += bet.amount_sats;
        else if (bet.outcome === 'no') noPool += bet.amount_sats;
      }

      const totalPool = yesPool + noPool;

      document.getElementById('yes-pool').textContent = `â‚¿${yesPool.toLocaleString()}`;
      document.getElementById('no-pool').textContent = `â‚¿${noPool.toLocaleString()}`;

      // Render bet list
      const betList = document.getElementById('bet-list');
      if (currentBets.length === 0) {
        betList.innerHTML = '<p style="color: #888; text-align: center; padding: 8px 0;">Be the first to bet!</p>';
      } else {
        betList.innerHTML = currentBets.slice(-10).reverse().map(b => `
          <div class="bet-item">
            <span>${b.outcome.toUpperCase()}</span>
            <span>â‚¿${b.amount_sats.toLocaleString()}</span>
          </div>
        `).join('');
      }

      // Check market state
      const now = new Date();
      const resolutionDate = new Date(c.resolution_date);

      if (currentResolution) {
        document.getElementById('betting-open').classList.add('hidden');
        document.getElementById('betting-closed').classList.add('hidden');
        document.getElementById('market-resolved').classList.remove('hidden');
        document.getElementById('resolved-outcome').textContent = currentResolution.winning_outcome.toUpperCase();
      } else if (now > resolutionDate) {
        document.getElementById('betting-open').classList.add('hidden');
        document.getElementById('betting-closed').classList.remove('hidden');
        document.getElementById('market-resolved').classList.add('hidden');
      } else {
        document.getElementById('betting-open').classList.remove('hidden');
        document.getElementById('betting-closed').classList.add('hidden');
        document.getElementById('market-resolved').classList.add('hidden');
        // Check for any pending unverified bets
        checkForPendingBet();
      }
    }

    // ============================================
    // BETTING
    // ============================================
    function updatePotentialWinnings() {
      const betAmount = parseInt(document.getElementById('bet-amount-input').value) || 0;
      const yesEl = document.getElementById('yes-potential');
      const noEl = document.getElementById('no-potential');

      if (betAmount <= 0) {
        yesEl.textContent = 'Enter amount above';
        noEl.textContent = 'Enter amount above';
        return;
      }

      // Get current pools
      let yesPool = 0;
      let noPool = 0;
      for (const bet of currentBets) {
        if (bet.outcome === 'yes') yesPool += bet.amount_sats;
        else if (bet.outcome === 'no') noPool += bet.amount_sats;
      }

      // Calculate what you'd win betting on YES
      // If you bet on YES: new yesPool = yesPool + betAmount
      // If YES wins: you get (betAmount / newYesPool) * (totalPool - fee)
      const newYesPool = yesPool + betAmount;
      const yesFeeTarget = Math.floor((newYesPool + noPool) * FEE_PERCENT / 100);
      const yesActualFee = Math.min(yesFeeTarget, noPool);
      const yesWinTotal = (newYesPool + noPool) - yesActualFee;
      const yesYourShare = Math.floor(betAmount / newYesPool * yesWinTotal);
      const yesProfit = yesYourShare - betAmount;

      // Calculate what you'd win betting on NO
      const newNoPool = noPool + betAmount;
      const noFeeTarget = Math.floor((yesPool + newNoPool) * FEE_PERCENT / 100);
      const noActualFee = Math.min(noFeeTarget, yesPool);
      const noWinTotal = (yesPool + newNoPool) - noActualFee;
      const noYourShare = Math.floor(betAmount / newNoPool * noWinTotal);
      const noProfit = noYourShare - betAmount;

      // Display results
      if (yesProfit > 0) {
        yesEl.innerHTML = `<span style="color: #4ade80;">+â‚¿${yesProfit.toLocaleString()}</span> <span style="color: #888;">(${(yesYourShare/betAmount).toFixed(2)}x)</span>`;
      } else if (yesProfit === 0) {
        yesEl.innerHTML = `<span style="color: #888;">Break even</span>`;
      } else {
        yesEl.innerHTML = `<span style="color: #f87171;">â‚¿${yesProfit.toLocaleString()}</span>`;
      }

      if (noProfit > 0) {
        noEl.innerHTML = `<span style="color: #4ade80;">+â‚¿${noProfit.toLocaleString()}</span> <span style="color: #888;">(${(noYourShare/betAmount).toFixed(2)}x)</span>`;
      } else if (noProfit === 0) {
        noEl.innerHTML = `<span style="color: #888;">Break even</span>`;
      } else {
        noEl.innerHTML = `<span style="color: #f87171;">â‚¿${noProfit.toLocaleString()}</span>`;
      }
    }
    window.updatePotentialWinnings = updatePotentialWinnings;

    function showBetError(message) {
      const el = document.getElementById('bet-error');
      el.textContent = message;
      el.classList.remove('hidden');
    }

    function hideBetError() {
      document.getElementById('bet-error').classList.add('hidden');
    }

    async function placeBet(outcome) {
      debug('Placing bet on', outcome);
      hideBetError();

      const payoutAddress = document.getElementById('payout-address-input').value.trim();
      const amount = parseInt(document.getElementById('bet-amount-input').value);

      // Require valid Lightning Address
      if (!payoutAddress || !payoutAddress.includes('@')) {
        showBetError('Please enter a valid Lightning Address (e.g. you@wallet.com)');
        return;
      }
      // Save for next time
      localStorage.setItem('lightning_address', payoutAddress);
      if (!amount || amount < 1) {
        showBetError('Please enter a bet amount');
        return;
      }
      if (currentMarket.content.max_bet_sats && amount > currentMarket.content.max_bet_sats) {
        showBetError(`Maximum bet is â‚¿${currentMarket.content.max_bet_sats.toLocaleString()}`);
        return;
      }

      // Check if we have NWC for this market
      if (!creatorNwcString) {
        showBetError('This prophecy cannot accept bets (creator wallet not connected)');
        return;
      }

      // Generate invoice via NWC
      try {
        document.getElementById('bet-form').classList.add('hidden');
        document.getElementById('bet-invoice').classList.remove('hidden');
        document.getElementById('payment-status').textContent = 'Generating invoice...';

        const result = await nwcRequest('make_invoice', {
          amount: amount * 1000, // millisats
          description: `Bet â‚¿${amount} on ${outcome.toUpperCase()} - ${currentMarket.content.question.slice(0, 50)}`
        });

        pendingInvoice = {
          paymentRequest: result.invoice,
          paymentHash: result.payment_hash,
          outcome,
          amount,
          payoutAddress,
          marketId: currentMarket.id,
          createdAt: Date.now()
        };

        // Save to localStorage in case user navigates away
        localStorage.setItem(`pending_bet_${currentMarket.id}`, JSON.stringify(pendingInvoice));

        // Show QR code
        document.getElementById('invoice-text').textContent = result.invoice;
        const qrContainer = document.getElementById('qr-container');
        qrContainer.innerHTML = '';
        new QRCode(qrContainer, {
          text: result.invoice,
          width: 200,
          height: 200
        });
        document.getElementById('payment-status').textContent = 'Waiting for payment...';

        // Start polling for payment via lookup_invoice
        startPaymentPolling();

      } catch (e) {
        console.error('Failed to create invoice', e);
        resetBetForm();
        showBetError('Failed to create invoice: ' + e.message);
      }
    }
    window.placeBet = placeBet;

    let pollingInterval = null;
    let pollingAttempts = 0;
    const MAX_POLLING_ATTEMPTS = 60; // 5 minutes at 5 second intervals

    async function startPaymentPolling() {
      if (pollingInterval) {
        clearInterval(pollingInterval);
      }
      pollingAttempts = 0;

      debug('=== STARTING PAYMENT POLLING ===');
      debug('Payment hash:', pendingInvoice?.paymentHash);

      pollingInterval = setInterval(async () => {
        if (!pendingInvoice) {
          debug('No pending invoice, stopping polling');
          clearInterval(pollingInterval);
          return;
        }

        pollingAttempts++;
        if (pollingAttempts > MAX_POLLING_ATTEMPTS) {
          debug('Max polling attempts reached, stopping');
          clearInterval(pollingInterval);
          document.getElementById('payment-status').textContent = 'Auto-verify timed out. Use manual verification below.';
          document.getElementById('manual-preimage-section').open = true;
          return;
        }

        try {
          debug(`Polling attempt ${pollingAttempts}/${MAX_POLLING_ATTEMPTS}`);
          const result = await checkPaymentStatus();
          if (result) {
            debug('Payment confirmed via lookup_invoice!');
            clearInterval(pollingInterval);
          }
        } catch (e) {
          console.error('Polling error:', e);
          // Continue polling despite errors
        }
      }, 5000); // Poll every 5 seconds
    }

    async function checkPaymentStatus() {
      if (!pendingInvoice) return false;

      const request = {
        method: 'lookup_invoice',
        params: {
          payment_hash: pendingInvoice.paymentHash
        }
      };

      debug('=== LOOKUP_INVOICE REQUEST ===');
      debug('Request:', JSON.stringify(request, null, 2));

      try {
        const result = await nwcRequest('lookup_invoice', request.params);

        debug('=== LOOKUP_INVOICE RESPONSE ===');
        debug('Response:', JSON.stringify(result, null, 2));

        // Check if invoice is settled - accept either preimage or settled_at as proof
        if (result && (result.preimage || result.settled_at)) {
          debug('Invoice settled!', result.preimage ? `Preimage: ${result.preimage}` : `Settled at: ${result.settled_at}`);
          document.getElementById('payment-status').textContent = 'Payment received! Recording bet...';

          // If we have preimage, verify it matches payment_hash
          if (result.preimage) {
            const preimageBytes = hexToBytes(result.preimage);
            const hashBuffer = await crypto.subtle.digest('SHA-256', preimageBytes);
            const hashHex = Array.from(new Uint8Array(hashBuffer))
              .map(b => b.toString(16).padStart(2, '0'))
              .join('');

            if (hashHex === pendingInvoice.paymentHash) {
              pendingInvoice.preimage = result.preimage;
              await recordBet();
              return true;
            } else {
              console.error('Preimage mismatch!', hashHex, '!==', pendingInvoice.paymentHash);
              return false;
            }
          } else {
            // No preimage, but wallet confirmed settlement via settled_at
            // Trust the NWC provider's confirmation
            debug('No preimage returned, but wallet confirmed payment via settled_at');
            pendingInvoice.settled_at = result.settled_at;
            await recordBet();
            return true;
          }
        } else if (result && result.state) {
          debug('Invoice state:', result.state);
          document.getElementById('payment-status').textContent = `Waiting for payment... (${result.state})`;
        }
      } catch (e) {
        console.error('lookup_invoice error:', e.message);
        // Log the full error for debugging with Primal
        debug('=== LOOKUP_INVOICE ERROR ===');
        debug('Error details:', e);
      }

      return false;
    }

    async function payWithWebLN() {
      if (!pendingInvoice) {
        alert('No pending invoice');
        return;
      }

      // Check for WebLN
      if (typeof window.webln === 'undefined') {
        alert('No WebLN wallet detected. Install Alby or another WebLN-compatible wallet, or pay manually and paste the preimage.');
        return;
      }

      try {
        document.getElementById('payment-status').textContent = 'Connecting to wallet...';

        // Enable WebLN
        await window.webln.enable();

        document.getElementById('payment-status').textContent = 'Requesting payment...';

        // Send payment - this returns the preimage!
        const response = await window.webln.sendPayment(pendingInvoice.paymentRequest);

        debug('WebLN payment response:', response);

        if (response.preimage) {
          document.getElementById('payment-status').textContent = 'Payment successful! Verifying...';
          pendingInvoice.preimage = response.preimage;

          // Verify the preimage matches
          const preimageBytes = hexToBytes(response.preimage);
          const hashBuffer = await crypto.subtle.digest('SHA-256', preimageBytes);
          const hashHex = Array.from(new Uint8Array(hashBuffer))
            .map(b => b.toString(16).padStart(2, '0'))
            .join('');

          if (hashHex === pendingInvoice.paymentHash) {
            debug('Preimage verified!');
            await recordBet();
          } else {
            console.error('Preimage mismatch:', hashHex, '!==', pendingInvoice.paymentHash);
            document.getElementById('payment-status').textContent = 'Payment received but verification failed. Contact support.';
          }
        } else {
          document.getElementById('payment-status').textContent = 'Payment sent but no preimage returned. Verify manually below.';
          document.getElementById('manual-preimage-section').open = true;
        }
      } catch (e) {
        console.error('WebLN payment error:', e);
        document.getElementById('payment-status').textContent = 'Payment failed: ' + (e.message || 'Unknown error');
      }
    }
    window.payWithWebLN = payWithWebLN;

    async function recordBet() {
      if (!pendingInvoice) return;

      document.getElementById('payment-status').textContent = 'Recording bet...';

      // Get creator's secret key from stored nsec or prompt
      let sk;
      const storedNsec = creatorNsec;
      if (storedNsec) {
        sk = decodeNsec(storedNsec);
      }

      // For now, we'll need the creator to be the one placing bets (since they sign)
      // In a real implementation, the creator's backend would do this
      // For MVP, we store the keypair in localStorage
      const storedSk = localStorage.getItem(`sk_${currentMarket.id}`);
      if (storedSk) {
        sk = hexToBytes(storedSk);
      }

      if (!sk) {
        // Generate ephemeral keypair for this bettor to sign their bet
        // Check if we already have one stored for this market
        let bettorSk = localStorage.getItem(`bettor_sk_${currentMarket.id}`);
        if (bettorSk) {
          sk = hexToBytes(bettorSk);
        } else {
          // Generate new ephemeral key for this bettor
          sk = generateSecretKey();
          localStorage.setItem(`bettor_sk_${currentMarket.id}`, bytesToHex(sk));
        }
      }

      // Create bet event with proof of payment (preimage or settled_at)
      const betContent = {
        type: 'bet',
        market_id: currentMarket.id,
        outcome: pendingInvoice.outcome,
        amount_sats: pendingInvoice.amount,
        payout_address: pendingInvoice.payoutAddress,
        payment_hash: pendingInvoice.paymentHash,
        preimage: pendingInvoice.preimage,
        settled_at: pendingInvoice.settled_at
      };

      const event = {
        kind: 1,
        created_at: Math.floor(Date.now() / 1000),
        tags: [
          ['t', 'prediction-market'],
          ['t', 'pm-bet'],
          ['e', currentMarket.id]
        ],
        content: JSON.stringify(betContent)
      };

      const signedEvent = finalizeEvent(event, sk);
      await publishEvent(signedEvent);

      // Show confirmation with bet details
      document.getElementById('bet-invoice').classList.add('hidden');
      document.getElementById('bet-confirmed').classList.remove('hidden');

      // Populate confirmation details
      const outcomeColor = pendingInvoice.outcome === 'yes' ? '#4ade80' : '#f87171';
      document.getElementById('confirmed-outcome').textContent = pendingInvoice.outcome.toUpperCase();
      document.getElementById('confirmed-outcome').style.color = outcomeColor;
      document.getElementById('confirmed-amount').textContent = `â‚¿${pendingInvoice.amount.toLocaleString()}`;

      // Calculate potential payout
      const currentYes = currentBets.filter(b => b.outcome === 'yes').reduce((sum, b) => sum + b.amount_sats, 0);
      const currentNo = currentBets.filter(b => b.outcome === 'no').reduce((sum, b) => sum + b.amount_sats, 0);
      const totalPool = currentYes + currentNo;
      const myPool = pendingInvoice.outcome === 'yes' ? currentYes : currentNo;
      const potentialPayout = Math.floor((totalPool * 0.95) * (pendingInvoice.amount / myPool));
      document.getElementById('confirmed-payout').textContent = `â‚¿${potentialPayout.toLocaleString()}`;

      currentBets.push({ ...betContent, id: signedEvent.id });
      renderMarket();
      // Stop polling and clean up
      if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
      }
      // Clear pending bet from localStorage
      if (pendingInvoice && pendingInvoice.marketId) {
        localStorage.removeItem(`pending_bet_${pendingInvoice.marketId}`);
      }
      pendingInvoice = null;
      closeNwcRelay();
    }

    function cancelBet() {
      // Stop polling
      if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
      }
      if (pendingInvoice && pendingInvoice.marketId) {
        localStorage.removeItem(`pending_bet_${pendingInvoice.marketId}`);
      }
      pendingInvoice = null;
      closeNwcRelay();
      resetBetForm();
    }
    window.cancelBet = cancelBet;

    function resetBetForm() {
      document.getElementById('bet-form').classList.remove('hidden');
      document.getElementById('bet-invoice').classList.add('hidden');
      document.getElementById('bet-confirmed').classList.add('hidden');
    }
    window.resetBetForm = resetBetForm;

    function copyInvoice() {
      navigator.clipboard.writeText(document.getElementById('invoice-text').textContent);
      alert('Copied!');
    }
    window.copyInvoice = copyInvoice;

    // Check for pending bet when loading a market
    function checkForPendingBet() {
      if (!currentMarket) return;

      const savedPendingBet = localStorage.getItem(`pending_bet_${currentMarket.id}`);
      if (savedPendingBet) {
        try {
          const pending = JSON.parse(savedPendingBet);
          // Check if invoice is less than 1 hour old (invoices typically expire in 1 hour)
          const ageMinutes = (Date.now() - pending.createdAt) / 1000 / 60;
          if (ageMinutes < 60) {
            pendingInvoice = pending;
            // Auto-recovery: check if this pending bet was actually paid
            debug('Found pending bet, checking if paid via lookup_invoice...');
            autoRecoverPendingBet();
          } else {
            // Invoice expired, clear it
            localStorage.removeItem(`pending_bet_${currentMarket.id}`);
          }
        } catch (e) {
          console.error('Failed to parse pending bet:', e);
          localStorage.removeItem(`pending_bet_${currentMarket.id}`);
        }
      }
    }

    async function autoRecoverPendingBet() {
      if (!pendingInvoice || !creatorNwcString) {
        debug('Cannot auto-recover: missing pending invoice or NWC');
        return;
      }

      try {
        const result = await nwcRequest('lookup_invoice', {
          payment_hash: pendingInvoice.paymentHash
        });

        debug('Auto-recovery lookup_invoice result:', result);

        if (result && (result.preimage || result.settled_at)) {
          debug('Pending bet was paid! Auto-recording...');
          if (result.preimage) {
            pendingInvoice.preimage = result.preimage;
          } else {
            pendingInvoice.settled_at = result.settled_at;
          }
          await recordBet();
          alert('Found a pending payment that was completed. Your bet has been recorded!');
        } else {
          debug('Pending bet was not paid, clearing...');
          localStorage.removeItem(`pending_bet_${currentMarket.id}`);
          pendingInvoice = null;
        }
      } catch (e) {
        console.error('Auto-recovery failed:', e);
        // Clear the pending bet since we can't verify it
        localStorage.removeItem(`pending_bet_${currentMarket.id}`);
        pendingInvoice = null;
      } finally {
        closeNwcRelay();
      }
    }

    // ============================================
    // CREATOR DASHBOARD
    // ============================================
    let creatorSk = null;
    let creatorPk = null;

    async function creatorLogin() {
      const nsecInput = document.getElementById('creator-nsec-input').value.trim();
      const sk = decodeNsec(nsecInput);

      if (!sk) {
        alert('Invalid nsec');
        return;
      }

      creatorSk = sk;
      creatorPk = getPublicKey(sk);

      // Save nsec for convenience (user can logout to clear)
      localStorage.setItem('creator_nsec', nsecInput);

      document.getElementById('creator-login').classList.add('hidden');
      document.getElementById('creator-dashboard').classList.remove('hidden');
      document.getElementById('creator-pubkey').textContent = creatorPk.slice(0, 8) + '...' + creatorPk.slice(-8);

      await loadCreatorMarkets();
    }
    window.creatorLogin = creatorLogin;

    function creatorLogout() {
      creatorSk = null;
      creatorPk = null;
      localStorage.removeItem('creator_nsec');
      document.getElementById('creator-nsec-input').value = '';
      document.getElementById('creator-login').classList.remove('hidden');
      document.getElementById('creator-dashboard').classList.add('hidden');
    }
    window.creatorLogout = creatorLogout;

    async function loadCreatorMarkets() {
      const listEl = document.getElementById('creator-markets-list');
      listEl.innerHTML = '<p style="color: #666;">Loading...</p>';

      try {
        const relays = await connectRelays();
        const filter = {
          kinds: [1],
          authors: [creatorPk],
          '#t': ['prediction-market']
        };

        const events = [];
        await new Promise((resolve) => {
          const sub = relays[0].subscribe([filter], {
            onevent(event) {
              events.push(event);
            },
            oneose() {
              sub.close();
              resolve();
            }
          });
          setTimeout(() => { sub.close(); resolve(); }, 5000);
        });

        // Filter to only market events
        const markets = events.filter(e => {
          try {
            const c = JSON.parse(e.content);
            return c.type === 'market';
          } catch { return false; }
        });

        if (markets.length === 0) {
          listEl.innerHTML = '<p style="color: #666;">No prophecies found for this account.</p>';
          return;
        }

        // Sort by created_at descending
        markets.sort((a, b) => b.created_at - a.created_at);

        listEl.innerHTML = markets.map(m => {
          const c = JSON.parse(m.content);
          const isPast = new Date(c.resolution_date) < new Date();
          return `
            <div class="card" style="margin-bottom: 12px; cursor: pointer;" onclick="openCreatorMarket('${m.id}')">
              <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                <div>
                  <strong>${c.question}</strong>
                  <p style="color: #888; font-size: 12px; margin: 4px 0 0 0;">
                    Resolves: ${new Date(c.resolution_date).toLocaleDateString()}
                  </p>
                </div>
                <span style="font-size: 11px; padding: 4px 8px; border-radius: 4px; background: ${isPast ? '#4a3000' : '#1a3a1a'}; color: ${isPast ? '#ffa500' : '#4ade80'};">
                  ${isPast ? 'Ready to resolve' : 'Active'}
                </span>
              </div>
            </div>
          `;
        }).join('');

      } catch (e) {
        console.error('Error loading creator markets:', e);
        listEl.innerHTML = '<p style="color: #f87171;">Error loading prophecies</p>';
      }
    }

    async function openCreatorMarket(marketId) {
      // Load the market and go to resolve view
      await loadMarketById(marketId);
      // Pre-fill the nsec in resolve view
      document.getElementById('resolve-nsec-input').value = localStorage.getItem('creator_nsec') || '';
      showView('resolve-view');
    }
    window.openCreatorMarket = openCreatorMarket;

    // Auto-login if nsec saved
    function checkCreatorSession() {
      const savedNsec = localStorage.getItem('creator_nsec');
      if (savedNsec) {
        document.getElementById('creator-nsec-input').value = savedNsec;
      }
    }

    // ============================================
    // RESOLUTION
    // ============================================
    async function resolveMarket(outcome) {
      debug('Resolving market:', outcome);
      const nsecInput = document.getElementById('resolve-nsec-input').value.trim();
      const sk = decodeNsec(nsecInput);

      if (!sk) {
        alert('Invalid nsec');
        return;
      }

      const pk = getPublicKey(sk);
      if (pk !== currentMarket.pubkey) {
        alert('This nsec does not match the prophecy creator');
        return;
      }

      // Create resolution event
      const resolutionContent = {
        type: 'resolution',
        market_id: currentMarket.id,
        winning_outcome: outcome
      };

      const event = {
        kind: 1,
        created_at: Math.floor(Date.now() / 1000),
        tags: [
          ['t', 'prediction-market'],
          ['t', 'pm-resolution'],
          ['e', currentMarket.id]
        ],
        content: JSON.stringify(resolutionContent)
      };

      const signedEvent = finalizeEvent(event, sk);
      const published = await publishEvent(signedEvent);

      if (!published) {
        alert('Failed to publish resolution');
        return;
      }

      currentResolution = resolutionContent;

      // Calculate payouts
      // Fee is 5% of total action, but capped so winners always get at least 1.0x
      const winners = currentBets.filter(b => b.outcome === outcome);
      const losers = currentBets.filter(b => b.outcome !== outcome);
      const winningPool = winners.reduce((sum, b) => sum + b.amount_sats, 0);
      const losingPool = losers.reduce((sum, b) => sum + b.amount_sats, 0);
      const totalPool = winningPool + losingPool;
      const feeTarget = Math.floor(totalPool * FEE_PERCENT / 100);
      const feeAmount = Math.min(feeTarget, losingPool); // Cap fee so winners get at least 1.0x
      const amountToWinners = totalPool - feeAmount;

      debug('=== PAYOUT CALCULATION ===');
      debug('Total bets:', currentBets.length);
      debug('Winners:', winners.length, 'Losers:', losers.length);
      debug('Winning pool:', winningPool, 'sats');
      debug('Losing pool:', losingPool, 'sats');
      debug('Total pool:', totalPool, 'sats');
      debug('Fee target (5% of total):', feeTarget, 'sats');
      debug('Fee actual (capped at losers):', feeAmount, 'sats');
      debug('Amount to winners:', amountToWinners, 'sats');

      const payouts = winners.map(b => {
        const payout = Math.floor(b.amount_sats / winningPool * amountToWinners);
        debug(`Winner bet ${b.amount_sats} sats, gets ${payout} sats (profit: ${payout - b.amount_sats})`);
        return {
          address: b.payout_address,
          amount: payout
        };
      });

      // Show payout section
      document.getElementById('resolve-form').classList.add('hidden');
      document.getElementById('payout-section').classList.remove('hidden');

      const payoutList = document.getElementById('payout-list');
      if (payouts.length === 0) {
        payoutList.innerHTML = '<p>No winners to pay out</p>';
      } else {
        const autoPayable = payouts.filter(p => p.address && p.address.includes('@'));
        const manualClaim = payouts.filter(p => !p.address || !p.address.includes('@'));

        let html = `
          <div style="background: #1a1a2e; padding: 12px; border-radius: 8px; margin-bottom: 16px; font-size: 13px;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
              <span>Total pool:</span><span>â‚¿${totalPool.toLocaleString()}</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
              <span>Creator fee (5%):</span><span>-â‚¿${feeAmount.toLocaleString()}</span>
            </div>
            <div style="display: flex; justify-content: space-between; border-top: 1px solid #333; padding-top: 4px; margin-top: 4px;">
              <span><strong>To ${winners.length} winner${winners.length !== 1 ? 's' : ''}:</strong></span><span><strong>â‚¿${amountToWinners.toLocaleString()}</strong></span>
            </div>
            <p style="margin: 8px 0 0 0; font-size: 11px; color: #666;">Lightning routing fees may slightly reduce actual payouts.</p>
          </div>
        `;
        if (autoPayable.length > 0) {
          html += '<h4>Auto-payable (have Lightning Address):</h4>';
          html += autoPayable.map(p => `
            <div class="bet-item">
              <span>${p.address}</span>
              <span>â‚¿${p.amount.toLocaleString()}</span>
            </div>
          `).join('');
        }
        if (manualClaim.length > 0) {
          html += '<h4>Manual claim (no Lightning Address):</h4>';
          html += manualClaim.map(p => `
            <div class="bet-item">
              <span style="color: #ff9800;">No address provided</span>
              <span>â‚¿${p.amount.toLocaleString()}</span>
            </div>
          `).join('');
          html += '<p style="font-size: 12px; color: #999;">Winners without addresses must contact you to claim their winnings.</p>';
        }
        payoutList.innerHTML = html;
      }

      // Store payouts for payment
      window.pendingPayouts = payouts;

      // Refresh market view
      renderMarket();
    }
    window.resolveMarket = resolveMarket;

    async function payAllWinners() {
      if (!window.pendingPayouts || window.pendingPayouts.length === 0) {
        alert('No payouts to send');
        return;
      }

      // Filter to only payouts with valid Lightning Addresses
      const autoPayable = window.pendingPayouts.filter(p => p.address && p.address.includes('@'));

      if (autoPayable.length === 0) {
        alert('No winners have Lightning Addresses. They must claim manually.');
        return;
      }

      if (!creatorNwcString) {
        creatorNwcString = localStorage.getItem(`nwc_${currentMarket.id}`);
        if (!creatorNwcString) {
          alert('NWC connection not found. Please paste your NWC string.');
          return;
        }
      }

      const statusEl = document.getElementById('payout-status');
      const payBtn = document.getElementById('btn-pay-winners');

      // Disable button to prevent double-payment
      payBtn.disabled = true;
      payBtn.textContent = 'Paying...';
      statusEl.innerHTML = '<div class="status info">Sending payouts...</div>';

      let successful = 0;
      let failed = 0;
      const manualCount = window.pendingPayouts.length - autoPayable.length;

      for (const payout of autoPayable) {
        try {
          statusEl.innerHTML = `<div class="status info">Paying ${payout.address} (â‚¿${payout.amount})...</div>`;

          // First, get an invoice from the Lightning Address
          const [name, domain] = payout.address.split('@');
          debug(`Fetching LNURL for ${name}@${domain}...`);
          const lnurlResponse = await fetch(`https://${domain}/.well-known/lnurlp/${name}`);
          const lnurlData = await lnurlResponse.json();
          debug('LNURL data:', lnurlData);

          if (lnurlData.status === 'ERROR') {
            throw new Error(`LNURL error: ${lnurlData.reason}`);
          }

          // Request an invoice
          const callbackUrl = new URL(lnurlData.callback);
          callbackUrl.searchParams.set('amount', payout.amount * 1000); // millisats
          debug('Requesting invoice from:', callbackUrl.toString());
          const invoiceResponse = await fetch(callbackUrl.toString());
          const invoiceData = await invoiceResponse.json();
          debug('Invoice data:', invoiceData);

          if (invoiceData.status === 'ERROR') {
            throw new Error(`Invoice error: ${invoiceData.reason}`);
          }
          if (!invoiceData.pr) {
            throw new Error('No invoice returned from Lightning Address');
          }

          // Pay the invoice
          debug('Paying invoice:', invoiceData.pr?.substring(0, 50) + '...');
          const payResult = await nwcRequest('pay_invoice', {
            invoice: invoiceData.pr
          });
          debug('Payment result:', payResult);

          // Verify we got a preimage back (proof of payment)
          if (payResult && payResult.preimage) {
            debug('Payment confirmed with preimage:', payResult.preimage);
            successful++;
          } else {
            console.warn('Payment returned but no preimage - may not have succeeded:', payResult);
            // Still count as success if no error was thrown, but log warning
            successful++;
          }
        } catch (e) {
          console.error('Failed to pay', payout.address, e);
          failed++;
        }
      }

      let msg = `Paid ${successful}/${autoPayable.length} winners with Lightning Addresses.`;
      if (failed > 0) msg += ` ${failed} failed.`;
      if (manualCount > 0) msg += ` ${manualCount} winner(s) need manual payout.`;

      statusEl.innerHTML = `<div class="status ${failed === 0 ? 'success' : 'warning'}">${msg}</div>`;

      if (failed === 0) {
        // All payments succeeded - keep button disabled
        payBtn.textContent = 'Paid';
        payBtn.classList.add('secondary');
        // Clear the pending payouts to prevent re-payment on page actions
        window.pendingPayouts = [];
      } else {
        // Some failed - allow retry but only for failed ones
        payBtn.disabled = false;
        payBtn.textContent = `Retry ${failed} Failed`;
        // Filter to only keep failed payouts for retry
        window.pendingPayouts = autoPayable.filter((_, i) => {
          // This is imperfect but helps prevent double-payment
          // In a real app, we'd track which specific payments succeeded
          return i >= successful;
        });
      }
    }
    window.payAllWinners = payAllWinners;

    // ============================================
    // INITIALIZATION
    // ============================================
    function setupEventListeners() {
      // Home view buttons
      document.getElementById('btn-create-view')?.addEventListener('click', () => showView('create-view'));

      // Create market buttons
      document.getElementById('btn-create-market')?.addEventListener('click', () => {
        createMarket();
      });
      document.getElementById('btn-cancel-create')?.addEventListener('click', () => showView('home-view'));

      // Prefill resolution date to 1 week from now
      const nextWeek = new Date();
      nextWeek.setDate(nextWeek.getDate() + 7);
      nextWeek.setHours(12, 0, 0, 0);
      const dateInput = document.getElementById('resolution-date-input');
      if (dateInput) {
        dateInput.value = nextWeek.toISOString().slice(0, 16);
      }

      console.log('Event listeners set up');
    }

    async function init() {
      setupEventListeners();
      checkCreatorSession();

      // Check for market ID in URL
      const params = new URLSearchParams(window.location.search);
      const marketId = params.get('m');

      if (marketId) {
        const eventId = decodeNoteId(marketId);
        if (eventId) {
          // Show loading view immediately
          showView('loading-view');
          await loadMarket(eventId);
          return;
        }
      }

      // Connect to relays in background
      connectRelays();
    }

    // ============================================
    // VERSION CHECK
    // ============================================
    const CURRENT_VERSION = '62';

    async function checkForUpdates() {
      try {
        const response = await fetch('version.txt?t=' + Date.now());
        const latestVersion = (await response.text()).trim();
        if (latestVersion !== CURRENT_VERSION) {
          document.getElementById('update-banner').style.display = 'block';
        }
      } catch (e) {
        // Silently fail - not critical
      }
    }

    // Check for updates every 5 minutes
    setInterval(checkForUpdates, 5 * 60 * 1000);

    // Also check when tab becomes visible
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        checkForUpdates();
      }
    });

    // Initial check after 10 seconds (let app load first)
    setTimeout(checkForUpdates, 10000);

    // Start
    console.log('Module loaded successfully');
    init();
  </script>
</body>
</html>
