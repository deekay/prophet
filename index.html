<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Prediction Markets</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      background: #0a0a0a;
      color: #e0e0e0;
      line-height: 1.6;
    }
    h1, h2, h3 {
      color: #fff;
    }
    a {
      color: #7cb3ff;
    }
    button {
      background: #2563eb;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      width: 100%;
      margin: 8px 0;
    }
    button:hover {
      background: #1d4ed8;
    }
    button:disabled {
      background: #444;
      cursor: not-allowed;
    }
    button.secondary {
      background: #333;
    }
    button.secondary:hover {
      background: #444;
    }
    button.yes {
      background: #16a34a;
    }
    button.yes:hover {
      background: #15803d;
    }
    button.no {
      background: #dc2626;
    }
    button.no:hover {
      background: #b91c1c;
    }
    input, textarea {
      width: 100%;
      padding: 12px;
      margin: 8px 0;
      border: 1px solid #333;
      border-radius: 6px;
      background: #1a1a1a;
      color: #e0e0e0;
      font-size: 16px;
    }
    input:focus, textarea:focus {
      outline: none;
      border-color: #2563eb;
    }
    label {
      display: block;
      margin-top: 16px;
      font-weight: 500;
    }
    .view {
      display: none;
    }
    .view.active {
      display: block;
    }
    .card {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 20px;
      margin: 16px 0;
    }
    .odds {
      display: flex;
      gap: 16px;
      margin: 16px 0;
    }
    .odds > div {
      flex: 1;
      text-align: center;
      padding: 16px;
      border-radius: 8px;
      background: #222;
    }
    .odds .outcome {
      font-size: 14px;
      color: #888;
      margin-bottom: 4px;
    }
    .odds .payout {
      font-size: 24px;
      font-weight: bold;
    }
    .odds .pool {
      font-size: 12px;
      color: #666;
      margin-top: 4px;
    }
    .status {
      padding: 12px;
      border-radius: 6px;
      margin: 16px 0;
    }
    .status.info {
      background: #1e3a5f;
      border: 1px solid #2563eb;
    }
    .status.success {
      background: #14532d;
      border: 1px solid #16a34a;
    }
    .status.error {
      background: #450a0a;
      border: 1px solid #dc2626;
    }
    .status.warning {
      background: #422006;
      border: 1px solid #d97706;
    }
    .qr-container {
      text-align: center;
      padding: 20px;
      background: white;
      border-radius: 8px;
      margin: 16px 0;
    }
    .qr-container img {
      max-width: 200px;
    }
    .invoice-text {
      font-family: monospace;
      font-size: 12px;
      word-break: break-all;
      background: #111;
      padding: 12px;
      border-radius: 6px;
      margin: 8px 0;
    }
    .nsec-warning {
      background: #422006;
      border: 1px solid #d97706;
      padding: 16px;
      border-radius: 8px;
      margin: 16px 0;
    }
    .nsec-display {
      font-family: monospace;
      background: #111;
      padding: 12px;
      border-radius: 6px;
      word-break: break-all;
      margin: 8px 0;
    }
    .bet-list {
      margin: 16px 0;
    }
    .bet-item {
      display: flex;
      justify-content: space-between;
      padding: 8px;
      border-bottom: 1px solid #333;
    }
    .bet-item:last-child {
      border-bottom: none;
    }
    .hidden {
      display: none;
    }
    .loader {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid #333;
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    footer {
      margin-top: 40px;
      padding-top: 20px;
      border-top: 1px solid #333;
      text-align: center;
      color: #666;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <!-- Loading View (for URL params) -->
  <div id="loading-view" class="view">
    <div style="text-align: center; padding: 60px 20px;">
      <div class="loader" style="margin: 0 auto;"></div>
      <p style="margin-top: 20px; color: #888;">Fetching market from Nostr relays...</p>
    </div>
  </div>

  <!-- Home View -->
  <div id="home-view" class="view active">
    <h1>Prediction Markets</h1>
    <p>Create and bet on predictions using Bitcoin. No accounts, no servers.</p>

    <button id="btn-create-view">Create a Market</button>
    <button id="btn-load-view" class="secondary">Load a Market</button>

    <div class="card">
      <h3>How it works</h3>
      <p><strong>Creators:</strong> Set up a question, share the link, collect bets, resolve, and pay winners. You keep 5%.</p>
      <p><strong>Bettors:</strong> Click a link, pick a side, pay with Lightning, get paid if you win.</p>
    </div>
  </div>

  <!-- Create Market View -->
  <div id="create-view" class="view">
    <h2>Create a Market</h2>

    <div id="create-step-1">
      <label>NWC Connection String</label>
      <input type="text" id="nwc-input" placeholder="nostr+walletconnect://..." />
      <p style="color: #888; font-size: 14px;">Get this from your NWC wallet (Alby Hub, Primal, etc.)</p>

      <label>Question</label>
      <input type="text" id="question-input" placeholder="Will X happen by Y date?" />

      <label>Resolution Date</label>
      <input type="datetime-local" id="resolution-date-input" />

      <label>Resolution Criteria</label>
      <textarea id="criteria-input" rows="3" placeholder="Yes if... No if..."></textarea>

      <label>Max Bet (sats, optional)</label>
      <input type="number" id="max-bet-input" placeholder="10000" />

      <button id="btn-create-market">Create Market</button>
      <div id="create-status" class="hidden" style="text-align: center; padding: 20px;">
        <div class="loader"></div>
        <p id="create-status-text" style="margin-top: 12px; color: #888;">Publishing to Nostr relays...</p>
      </div>
      <button id="btn-cancel-create" class="secondary">Cancel</button>
    </div>

    <div id="create-step-2" class="hidden">
      <div class="status success">Market created!</div>

      <div id="market-summary" style="background: #1a1a2e; border-radius: 8px; padding: 16px; margin-bottom: 20px;">
        <h3 id="summary-question" style="margin: 0 0 12px 0; color: #fff;"></h3>
        <p id="summary-details" style="margin: 0; color: #888; font-size: 14px;"></p>
      </div>

      <div class="nsec-warning">
        <strong>Save this secret key!</strong>
        <p>You need it to resolve the market later. Store it securely.</p>
        <div class="nsec-display" id="nsec-display"></div>
        <button onclick="copyNsec()">Copy to Clipboard</button>
      </div>

      <label>Share this link:</label>
      <input type="text" id="share-url" readonly />
      <button onclick="copyShareUrl()">Copy Link</button>
      <button class="secondary" onclick="goToMarket()">Go to Market</button>
    </div>
  </div>

  <!-- Load Market View -->
  <div id="load-view" class="view">
    <h2>Load a Market</h2>
    <p style="color: #888;">Paste a market URL or ID that was shared with you.</p>
    <label>Market URL or ID</label>
    <input type="text" id="market-id-input" placeholder="https://...?m=note1... or note1..." />
    <button id="btn-load-market">Load Market</button>
    <div id="load-status" class="hidden" style="text-align: center; padding: 20px;">
      <div class="loader"></div>
      <p style="margin-top: 12px; color: #888;">Fetching from Nostr relays...</p>
    </div>
    <button id="btn-back-load" class="secondary">Back</button>
  </div>

  <!-- Market View (Betting) -->
  <div id="market-view" class="view">
    <h2 id="market-question">Loading...</h2>

    <div class="card">
      <p><strong>Resolves:</strong> <span id="market-resolution-date"></span></p>
      <p><strong>Criteria:</strong></p>
      <p id="market-criteria" style="white-space: pre-wrap; margin: 8px 0 0 0; color: #ccc;"></p>
    </div>

    <div class="odds">
      <div>
        <div class="outcome">YES</div>
        <div class="payout" id="yes-payout">-</div>
        <div class="pool" id="yes-pool">0 sats</div>
      </div>
      <div>
        <div class="outcome">NO</div>
        <div class="payout" id="no-payout">-</div>
        <div class="pool" id="no-pool">0 sats</div>
      </div>
    </div>

    <div id="betting-open">
      <div id="bet-form">
        <label>Your Lightning Address (for payout) *</label>
        <input type="text" id="payout-address-input" placeholder="you@walletofsatoshi.com" required />

        <label>Bet Amount (sats)</label>
        <input type="number" id="bet-amount-input" placeholder="500" oninput="updatePotentialWinnings()" />

        <div id="potential-winnings" style="background: #1a1a2e; border-radius: 8px; padding: 12px; margin: 12px 0; font-size: 14px;">
          <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
            <span>If <strong style="color: #4ade80;">YES</strong> wins:</span>
            <span id="yes-potential">Enter amount above</span>
          </div>
          <div style="display: flex; justify-content: space-between;">
            <span>If <strong style="color: #f87171;">NO</strong> wins:</span>
            <span id="no-potential">Enter amount above</span>
          </div>
        </div>

        <div style="display: flex; gap: 16px;">
          <button class="yes" onclick="placeBet('yes')">Bet YES</button>
          <button class="no" onclick="placeBet('no')">Bet NO</button>
        </div>
      </div>

      <div id="bet-invoice" class="hidden">
        <div class="status info">Pay this invoice to confirm your bet:</div>
        <div class="qr-container" id="qr-container">
        </div>
        <div class="invoice-text" id="invoice-text"></div>
        <div id="webln-pay-section">
          <button id="btn-webln-pay" onclick="payWithWebLN()">Pay with Wallet</button>
          <p style="color: #666; font-size: 13px; margin-top: 4px;">Works with Alby and other WebLN wallets (recommended)</p>
        </div>

        <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #333;">
          <div style="margin-bottom: 12px; text-align: center; color: #555;">— or pay manually —</div>
          <button onclick="copyInvoice()">Copy Invoice</button>
        </div>

        <div id="auto-verify-section" style="margin-top: 20px; padding: 16px; background: #1a2a1a; border: 1px solid #4a4; border-radius: 8px; text-align: center;">
          <p id="payment-status" style="color: #6c6; margin: 0 0 8px 0; font-weight: bold; font-size: 15px;">Waiting for payment...</p>
          <p style="color: #888; margin: 0; font-size: 13px;">Payment will be verified automatically</p>
        </div>

        <details id="manual-preimage-section" style="margin-top: 16px;">
          <summary style="cursor: pointer; color: #666; font-size: 13px;">Payment not detected? Verify manually</summary>
          <div style="margin-top: 12px; padding: 12px; background: #1a1a1a; border-radius: 6px;">
            <p style="color: #aaa; margin: 0 0 12px 0; font-size: 13px;">Find the preimage in your wallet's transaction details and paste it below.</p>
            <input type="text" id="preimage-input" placeholder="Preimage from your wallet (hex)" />
            <button onclick="verifyPreimage()">Verify Payment</button>
          </div>
        </details>

        <div style="margin-top: 16px;">
          <button class="secondary" onclick="cancelBet()">Cancel (I haven't paid)</button>
        </div>
      </div>

      <div id="bet-confirmed" class="hidden">
        <div class="status success">Bet confirmed!</div>
        <p>Your bet has been recorded. If you win, payment will be sent to your Lightning Address.</p>
        <button onclick="resetBetForm()">Place Another Bet</button>
      </div>

      <details id="pending-bet-recovery" class="hidden" style="margin-top: 16px; padding: 12px; background: #1a1a1a; border-radius: 6px; border: 1px solid #333;">
        <summary style="cursor: pointer; color: #888; font-size: 13px;">Have an unverified payment? <span id="pending-bet-summary" style="color: #ff9966;"></span></summary>
        <div style="margin-top: 12px;">
          <p style="color: #aaa; margin: 0 0 12px 0; font-size: 13px;">If you paid but your bet wasn't recorded, paste the preimage from your wallet to verify.</p>
          <input type="text" id="recovery-preimage-input" placeholder="Preimage from your wallet (hex)" />
          <button onclick="verifyRecoveryPreimage()">Verify Payment</button>
          <button class="secondary" onclick="dismissPendingBet()">Dismiss</button>
        </div>
      </details>

      <details style="margin-top: 16px; padding: 12px; background: #1a1a1a; border-radius: 6px; border: 1px solid #333;">
        <summary style="cursor: pointer; color: #666; font-size: 13px;">Manual bet recovery (paid but not recorded?)</summary>
        <div style="margin-top: 12px;">
          <p style="color: #aaa; margin: 0 0 12px 0; font-size: 13px;">If you paid an invoice but the bet wasn't recorded, enter all details from your wallet to recover it.</p>
          <select id="manual-recovery-outcome" style="margin-bottom: 8px;">
            <option value="yes">YES</option>
            <option value="no">NO</option>
          </select>
          <input type="number" id="manual-recovery-amount" placeholder="Amount (sats)" style="margin-bottom: 8px;" />
          <input type="text" id="manual-recovery-address" placeholder="Your Lightning Address" style="margin-bottom: 8px;" />
          <input type="text" id="manual-recovery-hash" placeholder="Payment hash (from wallet)" style="margin-bottom: 8px;" />
          <input type="text" id="manual-recovery-preimage" placeholder="Payment preimage (from wallet)" style="margin-bottom: 8px;" />
          <button onclick="manualBetRecovery()">Recover Bet</button>
        </div>
      </details>
    </div>

    <div id="betting-closed" class="hidden">
      <div class="status warning">Betting is closed. Awaiting resolution.</div>
    </div>

    <div id="market-resolved" class="hidden">
      <div class="status success">
        <strong>Resolved:</strong> <span id="resolved-outcome"></span> won!
      </div>
    </div>

    <div class="card">
      <h3>Recent Bets</h3>
      <div id="bet-list" class="bet-list">
        <p style="color: #666;">No bets yet</p>
      </div>
    </div>

    <button class="secondary" onclick="showView('home-view')">Back to Home</button>
    <button class="secondary" onclick="showView('resolve-view')" id="resolve-btn">Resolve Market (Creator)</button>
  </div>

  <!-- Resolve View -->
  <div id="resolve-view" class="view">
    <h2>Resolve Market</h2>
    <p id="resolve-question"></p>

    <label>Your nsec (secret key)</label>
    <input type="password" id="resolve-nsec-input" placeholder="nsec1..." />

    <div id="resolve-form">
      <p>Select the winning outcome:</p>
      <button class="yes" onclick="resolveMarket('yes')">YES Won</button>
      <button class="no" onclick="resolveMarket('no')">NO Won</button>
    </div>

    <div id="payout-section" class="hidden">
      <div class="status success">Market resolved!</div>
      <h3>Payouts</h3>
      <div id="payout-list"></div>
      <button id="btn-pay-winners" onclick="payAllWinners()">Pay All Winners</button>
      <div id="payout-status"></div>
    </div>

    <button class="secondary" onclick="showView('market-view')">Back to Market</button>
  </div>

  <footer>
    <p>Powered by Nostr + Lightning</p>
    <p>Data stored on: relay.damus.io, relay.primal.net</p>
    <p style="font-size: 11px; color: #444; margin-top: 12px;" id="version">v27</p>
  </footer>

  <!-- Scripts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script type="module">
    // ============================================
    // IMPORTS
    // ============================================
    import { generateSecretKey, getPublicKey, finalizeEvent, verifyEvent } from 'https://esm.sh/nostr-tools@2.10.4';
    import { nsecEncode, npubEncode, noteEncode, decode as nip19Decode } from 'https://esm.sh/nostr-tools@2.10.4/nip19';
    import { Relay } from 'https://esm.sh/nostr-tools@2.10.4/relay';
    import { encrypt as nip04Encrypt, decrypt as nip04Decrypt } from 'https://esm.sh/nostr-tools@2.10.4/nip04';

    // ============================================
    // GLOBALS
    // ============================================
    const RELAYS = [
      'wss://relay.damus.io',
      'wss://relay.primal.net'
    ];
    const FEE_PERCENT = 5;

    let relayConnections = [];
    let currentMarket = null;
    let currentBets = [];
    let currentResolution = null;
    let creatorNsec = null;
    let creatorNwcString = null;
    let pendingInvoice = null;

    // ============================================
    // VIEW MANAGEMENT
    // ============================================
    function showView(viewId) {
      document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
      document.getElementById(viewId).classList.add('active');
    }
    window.showView = showView;

    // ============================================
    // NOSTR UTILITIES
    // ============================================
    function generateKeypair() {
      const sk = generateSecretKey();
      const pk = getPublicKey(sk);
      const nsec = nsecEncode(sk);
      const npub = npubEncode(pk);
      return { sk, pk, nsec, npub };
    }

    function decodeNsec(nsec) {
      try {
        const { type, data } = nip19Decode(nsec);
        if (type === 'nsec') return data;
      } catch (e) {
        console.error('Failed to decode nsec:', e);
      }
      return null;
    }

    function decodeNoteId(noteId) {
      try {
        if (noteId.startsWith('note1')) {
          const { type, data } = nip19Decode(noteId);
          if (type === 'note') return data;
        }
        // Assume hex
        if (/^[0-9a-f]{64}$/i.test(noteId)) return noteId;
      } catch (e) {
        console.error('Failed to decode note ID:', e);
      }
      return null;
    }

    async function connectRelays() {
      relayConnections = [];
      for (const url of RELAYS) {
        try {
          console.log('Connecting to', url);
          const relay = await Relay.connect(url);
          relayConnections.push(relay);
          console.log('Connected to', url);
        } catch (e) {
          console.error('Failed to connect to', url, e);
        }
      }
      console.log('Connected to', relayConnections.length, 'relays');
      return relayConnections.length > 0;
    }

    async function publishEvent(event) {
      let published = false;
      for (const relay of relayConnections) {
        try {
          await relay.publish(event);
          published = true;
          console.log('Published to', relay.url);
        } catch (e) {
          console.error('Failed to publish to', relay.url, e);
        }
      }
      return published;
    }

    async function fetchEvents(filter) {
      const events = [];
      const seen = new Set();

      console.log('Fetching events with filter:', filter);
      console.log('Relay connections:', relayConnections.length);

      // Reconnect if needed
      const activeRelays = relayConnections.filter(r => r.connected);
      console.log('Active relays:', activeRelays.length);

      if (activeRelays.length === 0) {
        console.log('No active relays, reconnecting...');
        relayConnections = [];
        await connectRelays();
      }

      for (const relay of relayConnections) {
        if (!relay.connected) {
          console.log('Skipping disconnected relay:', relay.url);
          continue;
        }
        try {
          console.log('Subscribing to', relay.url);
          const sub = relay.subscribe([filter], {
            onevent(event) {
              console.log('Got event from', relay.url, event.id);
              if (!seen.has(event.id)) {
                seen.add(event.id);
                events.push(event);
              }
            }
          });
          // Wait a bit for events to come in
          await new Promise(r => setTimeout(r, 3000));
          sub.close();
        } catch (e) {
          console.error('Failed to fetch from', relay.url, e);
        }
      }
      console.log('Total events found:', events.length);
      return events;
    }

    // ============================================
    // NWC UTILITIES
    // ============================================
    function parseNwcString(nwcString) {
      try {
        // Format: nostr+walletconnect://<pubkey>?relay=<relay>&secret=<secret>
        const url = new URL(nwcString.replace('nostr+walletconnect://', 'https://'));
        const pubkey = url.hostname || url.pathname.replace('//', '');
        const relay = url.searchParams.get('relay');
        const secret = url.searchParams.get('secret');
        return { pubkey, relay, secret };
      } catch (e) {
        console.error('Failed to parse NWC string', e);
        return null;
      }
    }

    // Cached NWC relay connection
    let nwcRelay = null;
    let nwcRelayConnecting = false;

    async function getNwcRelay() {
      const nwc = parseNwcString(creatorNwcString);
      if (!nwc) throw new Error('Invalid NWC connection');

      // Return existing connection if valid
      if (nwcRelay && nwcRelay.connected) {
        return nwcRelay;
      }

      // Wait if already connecting
      if (nwcRelayConnecting) {
        await new Promise(r => setTimeout(r, 500));
        return getNwcRelay();
      }

      // Create new connection
      nwcRelayConnecting = true;
      try {
        console.log('Connecting to NWC relay:', nwc.relay);
        nwcRelay = await Relay.connect(nwc.relay);
        console.log('Connected to NWC relay');
        return nwcRelay;
      } finally {
        nwcRelayConnecting = false;
      }
    }

    function closeNwcRelay() {
      if (nwcRelay) {
        try { nwcRelay.close(); } catch (e) {}
        nwcRelay = null;
      }
    }

    async function nwcRequest(method, params = {}) {
      console.log('NWC request:', method, params);
      const nwc = parseNwcString(creatorNwcString);
      if (!nwc) throw new Error('Invalid NWC connection');

      // NWC secret is hex-encoded
      const secretKey = hexToBytes(nwc.secret);

      // Get or create relay connection
      const relay = await getNwcRelay();

      // Create request
      const request = {
        method,
        params
      };

      const content = await nip04Encrypt(secretKey, nwc.pubkey, JSON.stringify(request));

      const event = {
        kind: 23194,
        created_at: Math.floor(Date.now() / 1000),
        tags: [['p', nwc.pubkey]],
        content
      };

      const signedEvent = finalizeEvent(event, secretKey);
      await relay.publish(signedEvent);

      // Wait for response
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          sub.close();
          reject(new Error('NWC request timeout'));
        }, 30000);

        const filter = {
          kinds: [23195],
          '#e': [signedEvent.id],
          '#p': [signedEvent.pubkey],
          since: Math.floor(Date.now() / 1000) - 10
        };
        console.log('NWC subscribing with filter:', JSON.stringify(filter, null, 2));
        console.log('Our pubkey (from signed event):', signedEvent.pubkey);
        console.log('Request event ID:', signedEvent.id);

        // Debug: also subscribe without tag filters to see if ANY 23195 events come through
        const debugFilter = { kinds: [23195], since: Math.floor(Date.now() / 1000) - 10 };
        const debugSub = relay.subscribe([debugFilter], {
          onevent(event) {
            console.log('=== DEBUG: Got 23195 event (unfiltered) ===');
            console.log('Event ID:', event.id);
            console.log('Event tags:', JSON.stringify(event.tags));
            console.log('Looking for #e:', signedEvent.id);
            console.log('Looking for #p:', signedEvent.pubkey);
          }
        });
        setTimeout(() => debugSub.close(), 35000);

        const sub = relay.subscribe([filter], {
          async onevent(event) {
            console.log('=== FILTERED: Got matching 23195 event ===');
            try {
              const decrypted = await nip04Decrypt(secretKey, nwc.pubkey, event.content);
              const response = JSON.parse(decrypted);
              clearTimeout(timeout);
              sub.close();
              debugSub.close();
              // Don't close relay - keep it for future requests
              if (response.error) {
                reject(new Error(response.error.message || 'NWC error'));
              } else {
                resolve(response.result);
              }
            } catch (e) {
              reject(e);
            }
          },
          oneose() {
            console.log('NWC subscription EOSE (end of stored events)');
          }
        });
        console.log('=== FOR CARLOS @ PRIMAL ===');
        console.log('Request event ID:', signedEvent.id);
        console.log('Subscription ID:', sub.id || sub.subId || 'not exposed by nostr-tools');
        console.log('Filter:', JSON.stringify(filter));
        console.log('Relay:', relay.url);
      });
    }

    function hexToBytes(hex) {
      const bytes = new Uint8Array(hex.length / 2);
      for (let i = 0; i < hex.length; i += 2) {
        bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
      }
      return bytes;
    }

    function bytesToHex(bytes) {
      return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // ============================================
    // CREATE MARKET
    // ============================================
    function setCreateStatus(show, text = 'Publishing to Nostr relays...') {
      const btn = document.getElementById('btn-create-market');
      const status = document.getElementById('create-status');
      const statusText = document.getElementById('create-status-text');
      if (show) {
        btn.classList.add('hidden');
        status.classList.remove('hidden');
        statusText.textContent = text;
      } else {
        btn.classList.remove('hidden');
        status.classList.add('hidden');
      }
    }

    async function createMarket() {
      console.log('Creating market...');
      try {

      const nwcString = document.getElementById('nwc-input').value.trim();
      const question = document.getElementById('question-input').value.trim();
      const resolutionDate = document.getElementById('resolution-date-input').value;
      const criteria = document.getElementById('criteria-input').value.trim();
      const maxBet = document.getElementById('max-bet-input').value;

      if (!nwcString || !question || !resolutionDate || !criteria) {
        alert('Please fill in all required fields');
        return;
      }

      setCreateStatus(true, 'Connecting to relays...');
      creatorNwcString = nwcString;

      // Generate keypair for this market
      console.log('Generating keypair...');
      const keypair = generateKeypair();
      creatorNsec = keypair.nsec;
      console.log('Keypair generated:', keypair.npub);

      // Connect to relays
      if (relayConnections.length === 0) {
        console.log('Connecting to relays...');
        const connected = await connectRelays();
        if (!connected) {
          setCreateStatus(false);
          alert('Failed to connect to relays');
          return;
        }
      }
      setCreateStatus(true, 'Publishing to Nostr relays...');

      // Create market event
      const marketContent = {
        type: 'market',
        question,
        resolution_date: new Date(resolutionDate).toISOString(),
        resolution_criteria: criteria
      };
      if (maxBet) {
        marketContent.max_bet_sats = parseInt(maxBet);
      }

      const event = {
        kind: 1,
        created_at: Math.floor(Date.now() / 1000),
        tags: [
          ['t', 'prediction-market'],
          ['t', 'pm-market']
        ],
        content: JSON.stringify(marketContent)
      };

      console.log('Signing event...');
      const signedEvent = finalizeEvent(event, keypair.sk);
      console.log('Event signed:', signedEvent.id);

      console.log('Publishing event...');
      const published = await publishEvent(signedEvent);
      if (!published) {
        setCreateStatus(false);
        alert('Failed to publish market');
        return;
      }
      console.log('Event published!');
      setCreateStatus(false);

      // Store NWC and SK in localStorage for this market
      localStorage.setItem(`nwc_${signedEvent.id}`, nwcString);
      localStorage.setItem(`sk_${signedEvent.id}`, bytesToHex(keypair.sk));

      // Show success
      document.getElementById('nsec-display').textContent = keypair.nsec;
      document.getElementById('share-url').value = `${window.location.origin}${window.location.pathname}?m=${noteEncode(signedEvent.id)}`;

      // Show market summary
      document.getElementById('summary-question').textContent = marketContent.question;
      const resDate = new Date(marketContent.resolution_date).toLocaleDateString();
      let details = `Resolves: ${resDate}`;
      if (marketContent.max_bet_sats) {
        details += ` · Max bet: ${marketContent.max_bet_sats.toLocaleString()} sats`;
      }
      document.getElementById('summary-details').textContent = details;

      document.getElementById('create-step-1').classList.add('hidden');
      document.getElementById('create-step-2').classList.remove('hidden');

      currentMarket = {
        id: signedEvent.id,
        pubkey: keypair.pk,
        content: marketContent,
        event: signedEvent
      };

      } catch (e) {
        console.error('Error creating market:', e);
        setCreateStatus(false);
        alert('Error creating market: ' + e.message);
      }
    }
    window.createMarket = createMarket;

    function copyNsec() {
      navigator.clipboard.writeText(document.getElementById('nsec-display').textContent);
      alert('Copied!');
    }
    window.copyNsec = copyNsec;

    function copyShareUrl() {
      navigator.clipboard.writeText(document.getElementById('share-url').value);
      alert('Copied!');
    }
    window.copyShareUrl = copyShareUrl;

    function goToMarket() {
      window.location.href = document.getElementById('share-url').value;
    }
    window.goToMarket = goToMarket;

    // ============================================
    // LOAD MARKET
    // ============================================
    async function loadMarketById() {
      let input = document.getElementById('market-id-input').value.trim();

      // If it's a URL, extract the market ID from it
      if (input.includes('?m=')) {
        try {
          const url = new URL(input);
          input = url.searchParams.get('m') || input;
        } catch (e) {
          // Not a valid URL, try as-is
        }
      }

      const eventId = decodeNoteId(input);
      if (!eventId) {
        alert('Invalid market URL or ID');
        return;
      }

      // Show loading state
      document.getElementById('btn-load-market').classList.add('hidden');
      document.getElementById('load-status').classList.remove('hidden');

      try {
        await loadMarket(eventId);
      } finally {
        document.getElementById('btn-load-market').classList.remove('hidden');
        document.getElementById('load-status').classList.add('hidden');
      }
    }
    window.loadMarketById = loadMarketById;

    async function loadMarket(eventId) {
      console.log('Loading market:', eventId);

      // Connect to relays
      if (relayConnections.length === 0) {
        const connected = await connectRelays();
        if (!connected) {
          alert('Failed to connect to relays');
          return;
        }
      }

      // Fetch market event
      const marketEvents = await fetchEvents({
        ids: [eventId],
        kinds: [1]
      });

      console.log('Market events found:', marketEvents.length);

      if (marketEvents.length === 0) {
        alert('Market not found. Check console for details.');
        return;
      }

      const marketEvent = marketEvents[0];
      let content;
      try {
        content = JSON.parse(marketEvent.content);
        if (content.type !== 'market') throw new Error('Not a market event');
      } catch (e) {
        alert('Invalid market event');
        return;
      }

      currentMarket = {
        id: eventId,
        pubkey: marketEvent.pubkey,
        content,
        event: marketEvent
      };

      // Load NWC from localStorage if we're the creator
      const storedNwc = localStorage.getItem(`nwc_${eventId}`);
      if (storedNwc) {
        creatorNwcString = storedNwc;
      }

      // Fetch bets
      const betEvents = await fetchEvents({
        kinds: [1],
        '#t': ['pm-bet'],
        '#e': [eventId]
      });

      currentBets = betEvents.map(e => {
        try {
          return { ...JSON.parse(e.content), id: e.id, created_at: e.created_at };
        } catch {
          return null;
        }
      }).filter(b => b && b.type === 'bet');

      // Fetch resolution
      const resolutionEvents = await fetchEvents({
        kinds: [1],
        '#t': ['pm-resolution'],
        '#e': [eventId]
      });

      currentResolution = null;
      for (const e of resolutionEvents) {
        try {
          const r = JSON.parse(e.content);
          if (r.type === 'resolution' && e.pubkey === marketEvent.pubkey) {
            currentResolution = r;
            break;
          }
        } catch {}
      }

      renderMarket();
      showView('market-view');
    }

    function renderMarket() {
      if (!currentMarket) return;

      const c = currentMarket.content;
      document.getElementById('market-question').textContent = c.question;
      document.getElementById('market-resolution-date').textContent = new Date(c.resolution_date).toLocaleString();
      document.getElementById('market-criteria').textContent = c.resolution_criteria;
      document.getElementById('resolve-question').textContent = c.question;

      // Calculate pools
      let yesPool = 0;
      let noPool = 0;
      for (const bet of currentBets) {
        if (bet.outcome === 'yes') yesPool += bet.amount_sats;
        else if (bet.outcome === 'no') noPool += bet.amount_sats;
      }

      const totalPool = yesPool + noPool;

      document.getElementById('yes-pool').textContent = `${yesPool.toLocaleString()} sats`;
      document.getElementById('no-pool').textContent = `${noPool.toLocaleString()} sats`;

      // Calculate payouts: 5% fee on total action, but winners always get at least 1.0x
      // Fee is capped so it never exceeds the losing pool (winners can't lose money)
      const yesPayoutEl = document.getElementById('yes-payout');
      const noPayoutEl = document.getElementById('no-payout');

      if (totalPool > 0) {
        // If YES wins
        const yesFeeTarget = Math.floor(totalPool * FEE_PERCENT / 100);
        const yesActualFee = Math.min(yesFeeTarget, noPool);
        const yesWinPayout = totalPool - yesActualFee;

        // If NO wins
        const noFeeTarget = Math.floor(totalPool * FEE_PERCENT / 100);
        const noActualFee = Math.min(noFeeTarget, yesPool);
        const noWinPayout = totalPool - noActualFee;

        // Display YES payout
        if (yesPool > 0 && noPool > 0) {
          yesPayoutEl.textContent = (yesWinPayout / yesPool).toFixed(2) + 'x';
        } else if (yesPool > 0 && noPool === 0) {
          // Show hypothetical: what if equal amount bet on NO?
          const hypotheticalTotal = yesPool * 2;
          const hypotheticalFee = Math.floor(hypotheticalTotal * FEE_PERCENT / 100);
          const hypotheticalPayout = (hypotheticalTotal - hypotheticalFee) / yesPool;
          yesPayoutEl.innerHTML = `<span style="color: #888; font-size: 14px;">~${hypotheticalPayout.toFixed(1)}x if matched</span>`;
        } else {
          yesPayoutEl.innerHTML = `<span style="color: #888; font-size: 14px;">Be first</span>`;
        }

        // Display NO payout
        if (noPool > 0 && yesPool > 0) {
          noPayoutEl.textContent = (noWinPayout / noPool).toFixed(2) + 'x';
        } else if (noPool > 0 && yesPool === 0) {
          const hypotheticalTotal = noPool * 2;
          const hypotheticalFee = Math.floor(hypotheticalTotal * FEE_PERCENT / 100);
          const hypotheticalPayout = (hypotheticalTotal - hypotheticalFee) / noPool;
          noPayoutEl.innerHTML = `<span style="color: #888; font-size: 14px;">~${hypotheticalPayout.toFixed(1)}x if matched</span>`;
        } else {
          noPayoutEl.innerHTML = `<span style="color: #888; font-size: 14px;">Be first</span>`;
        }
      } else {
        yesPayoutEl.innerHTML = `<span style="color: #888; font-size: 14px;">Be first</span>`;
        noPayoutEl.innerHTML = `<span style="color: #888; font-size: 14px;">Be first</span>`;
      }

      // Render bet list
      const betList = document.getElementById('bet-list');
      if (currentBets.length === 0) {
        betList.innerHTML = '<p style="color: #666;">No bets yet</p>';
      } else {
        betList.innerHTML = currentBets.slice(-10).reverse().map(b => `
          <div class="bet-item">
            <span>${b.outcome.toUpperCase()}</span>
            <span>${b.amount_sats.toLocaleString()} sats</span>
          </div>
        `).join('');
      }

      // Check market state
      const now = new Date();
      const resolutionDate = new Date(c.resolution_date);

      if (currentResolution) {
        document.getElementById('betting-open').classList.add('hidden');
        document.getElementById('betting-closed').classList.add('hidden');
        document.getElementById('market-resolved').classList.remove('hidden');
        document.getElementById('resolved-outcome').textContent = currentResolution.winning_outcome.toUpperCase();
      } else if (now > resolutionDate) {
        document.getElementById('betting-open').classList.add('hidden');
        document.getElementById('betting-closed').classList.remove('hidden');
        document.getElementById('market-resolved').classList.add('hidden');
      } else {
        document.getElementById('betting-open').classList.remove('hidden');
        document.getElementById('betting-closed').classList.add('hidden');
        document.getElementById('market-resolved').classList.add('hidden');
        // Check for any pending unverified bets
        checkForPendingBet();
      }
    }

    // ============================================
    // BETTING
    // ============================================
    function updatePotentialWinnings() {
      const betAmount = parseInt(document.getElementById('bet-amount-input').value) || 0;
      const yesEl = document.getElementById('yes-potential');
      const noEl = document.getElementById('no-potential');

      if (betAmount <= 0) {
        yesEl.textContent = 'Enter amount above';
        noEl.textContent = 'Enter amount above';
        return;
      }

      // Get current pools
      let yesPool = 0;
      let noPool = 0;
      for (const bet of currentBets) {
        if (bet.outcome === 'yes') yesPool += bet.amount_sats;
        else if (bet.outcome === 'no') noPool += bet.amount_sats;
      }

      // Calculate what you'd win betting on YES
      // If you bet on YES: new yesPool = yesPool + betAmount
      // If YES wins: you get (betAmount / newYesPool) * (totalPool - fee)
      const newYesPool = yesPool + betAmount;
      const yesFeeTarget = Math.floor((newYesPool + noPool) * FEE_PERCENT / 100);
      const yesActualFee = Math.min(yesFeeTarget, noPool);
      const yesWinTotal = (newYesPool + noPool) - yesActualFee;
      const yesYourShare = Math.floor(betAmount / newYesPool * yesWinTotal);
      const yesProfit = yesYourShare - betAmount;

      // Calculate what you'd win betting on NO
      const newNoPool = noPool + betAmount;
      const noFeeTarget = Math.floor((yesPool + newNoPool) * FEE_PERCENT / 100);
      const noActualFee = Math.min(noFeeTarget, yesPool);
      const noWinTotal = (yesPool + newNoPool) - noActualFee;
      const noYourShare = Math.floor(betAmount / newNoPool * noWinTotal);
      const noProfit = noYourShare - betAmount;

      // Display results
      if (yesProfit > 0) {
        yesEl.innerHTML = `<span style="color: #4ade80;">+${yesProfit.toLocaleString()} sats</span> <span style="color: #888;">(${(yesYourShare/betAmount).toFixed(2)}x)</span>`;
      } else if (yesProfit === 0) {
        yesEl.innerHTML = `<span style="color: #888;">Break even</span>`;
      } else {
        yesEl.innerHTML = `<span style="color: #f87171;">${yesProfit.toLocaleString()} sats</span>`;
      }

      if (noProfit > 0) {
        noEl.innerHTML = `<span style="color: #4ade80;">+${noProfit.toLocaleString()} sats</span> <span style="color: #888;">(${(noYourShare/betAmount).toFixed(2)}x)</span>`;
      } else if (noProfit === 0) {
        noEl.innerHTML = `<span style="color: #888;">Break even</span>`;
      } else {
        noEl.innerHTML = `<span style="color: #f87171;">${noProfit.toLocaleString()} sats</span>`;
      }
    }
    window.updatePotentialWinnings = updatePotentialWinnings;

    async function placeBet(outcome) {
      console.log('Placing bet on', outcome);
      const payoutAddress = document.getElementById('payout-address-input').value.trim();
      const amount = parseInt(document.getElementById('bet-amount-input').value);

      // Require valid Lightning Address
      if (!payoutAddress || !payoutAddress.includes('@')) {
        alert('Please enter a valid Lightning Address (user@domain.com)');
        return;
      }
      if (!amount || amount < 1) {
        alert('Please enter a valid amount');
        return;
      }
      if (currentMarket.content.max_bet_sats && amount > currentMarket.content.max_bet_sats) {
        alert(`Maximum bet is ${currentMarket.content.max_bet_sats} sats`);
        return;
      }

      // Check if we have NWC for this market
      if (!creatorNwcString) {
        alert('This market cannot accept bets (creator wallet not connected)');
        return;
      }

      // Generate invoice via NWC
      try {
        document.getElementById('bet-form').classList.add('hidden');
        document.getElementById('bet-invoice').classList.remove('hidden');
        document.getElementById('payment-status').textContent = 'Generating invoice...';

        const result = await nwcRequest('make_invoice', {
          amount: amount * 1000, // millisats
          description: `Bet ${amount} sats on ${outcome.toUpperCase()} - ${currentMarket.content.question.slice(0, 50)}`
        });

        pendingInvoice = {
          paymentRequest: result.invoice,
          paymentHash: result.payment_hash,
          outcome,
          amount,
          payoutAddress,
          marketId: currentMarket.id,
          createdAt: Date.now()
        };

        // Save to localStorage in case user navigates away
        localStorage.setItem(`pending_bet_${currentMarket.id}`, JSON.stringify(pendingInvoice));

        // Show QR code
        document.getElementById('invoice-text').textContent = result.invoice;
        const qrContainer = document.getElementById('qr-container');
        qrContainer.innerHTML = '';
        new QRCode(qrContainer, {
          text: result.invoice,
          width: 200,
          height: 200
        });
        document.getElementById('payment-status').textContent = 'Waiting for payment...';

        // Clear preimage input for new bet
        document.getElementById('preimage-input').value = '';

        // Start polling for payment via lookup_invoice
        startPaymentPolling();

      } catch (e) {
        console.error('Failed to create invoice', e);
        alert('Failed to create invoice: ' + e.message);
        resetBetForm();
      }
    }
    window.placeBet = placeBet;

    let pollingInterval = null;
    let pollingAttempts = 0;
    const MAX_POLLING_ATTEMPTS = 60; // 5 minutes at 5 second intervals

    async function startPaymentPolling() {
      if (pollingInterval) {
        clearInterval(pollingInterval);
      }
      pollingAttempts = 0;

      console.log('=== STARTING PAYMENT POLLING ===');
      console.log('Payment hash:', pendingInvoice?.paymentHash);

      pollingInterval = setInterval(async () => {
        if (!pendingInvoice) {
          console.log('No pending invoice, stopping polling');
          clearInterval(pollingInterval);
          return;
        }

        pollingAttempts++;
        if (pollingAttempts > MAX_POLLING_ATTEMPTS) {
          console.log('Max polling attempts reached, stopping');
          clearInterval(pollingInterval);
          document.getElementById('payment-status').textContent = 'Auto-verify timed out. Use manual verification below.';
          document.getElementById('manual-preimage-section').open = true;
          return;
        }

        try {
          console.log(`Polling attempt ${pollingAttempts}/${MAX_POLLING_ATTEMPTS}`);
          const result = await checkPaymentStatus();
          if (result) {
            console.log('Payment confirmed via lookup_invoice!');
            clearInterval(pollingInterval);
          }
        } catch (e) {
          console.error('Polling error:', e);
          // Continue polling despite errors
        }
      }, 5000); // Poll every 5 seconds
    }

    async function checkPaymentStatus() {
      if (!pendingInvoice) return false;

      const request = {
        method: 'lookup_invoice',
        params: {
          payment_hash: pendingInvoice.paymentHash
        }
      };

      console.log('=== LOOKUP_INVOICE REQUEST ===');
      console.log('Request:', JSON.stringify(request, null, 2));

      try {
        const result = await nwcRequest('lookup_invoice', request.params);

        console.log('=== LOOKUP_INVOICE RESPONSE ===');
        console.log('Response:', JSON.stringify(result, null, 2));

        // Check if invoice is settled
        if (result && result.preimage) {
          console.log('Invoice settled! Preimage:', result.preimage);
          document.getElementById('payment-status').textContent = 'Payment received! Recording bet...';

          // Verify preimage matches
          const preimageBytes = hexToBytes(result.preimage);
          const hashBuffer = await crypto.subtle.digest('SHA-256', preimageBytes);
          const hashHex = Array.from(new Uint8Array(hashBuffer))
            .map(b => b.toString(16).padStart(2, '0'))
            .join('');

          if (hashHex === pendingInvoice.paymentHash) {
            pendingInvoice.preimage = result.preimage;
            await recordBet();
            return true;
          } else {
            console.error('Preimage mismatch!', hashHex, '!==', pendingInvoice.paymentHash);
          }
        } else if (result && result.state) {
          console.log('Invoice state:', result.state);
          document.getElementById('payment-status').textContent = `Waiting for payment... (${result.state})`;
        }
      } catch (e) {
        console.error('lookup_invoice error:', e.message);
        // Log the full error for debugging with Primal
        console.log('=== LOOKUP_INVOICE ERROR ===');
        console.log('Error details:', e);
      }

      return false;
    }

    async function payWithWebLN() {
      if (!pendingInvoice) {
        alert('No pending invoice');
        return;
      }

      // Check for WebLN
      if (typeof window.webln === 'undefined') {
        alert('No WebLN wallet detected. Install Alby or another WebLN-compatible wallet, or pay manually and paste the preimage.');
        return;
      }

      try {
        document.getElementById('payment-status').textContent = 'Connecting to wallet...';

        // Enable WebLN
        await window.webln.enable();

        document.getElementById('payment-status').textContent = 'Requesting payment...';

        // Send payment - this returns the preimage!
        const response = await window.webln.sendPayment(pendingInvoice.paymentRequest);

        console.log('WebLN payment response:', response);

        if (response.preimage) {
          document.getElementById('payment-status').textContent = 'Payment successful! Verifying...';
          pendingInvoice.preimage = response.preimage;

          // Verify the preimage matches
          const preimageBytes = hexToBytes(response.preimage);
          const hashBuffer = await crypto.subtle.digest('SHA-256', preimageBytes);
          const hashHex = Array.from(new Uint8Array(hashBuffer))
            .map(b => b.toString(16).padStart(2, '0'))
            .join('');

          if (hashHex === pendingInvoice.paymentHash) {
            console.log('Preimage verified!');
            await recordBet();
          } else {
            console.error('Preimage mismatch:', hashHex, '!==', pendingInvoice.paymentHash);
            document.getElementById('payment-status').textContent = 'Payment received but verification failed. Contact support.';
          }
        } else {
          document.getElementById('payment-status').textContent = 'Payment sent but no preimage returned. Verify manually below.';
          document.getElementById('manual-preimage-section').open = true;
        }
      } catch (e) {
        console.error('WebLN payment error:', e);
        document.getElementById('payment-status').textContent = 'Payment failed: ' + (e.message || 'Unknown error');
      }
    }
    window.payWithWebLN = payWithWebLN;

    async function verifyPreimage() {
      if (!pendingInvoice) {
        alert('No pending invoice');
        return;
      }

      const preimageHex = document.getElementById('preimage-input').value.trim();
      if (!preimageHex || preimageHex.length !== 64) {
        alert('Please enter a valid preimage (64 hex characters)');
        return;
      }

      document.getElementById('payment-status').textContent = 'Verifying...';

      try {
        // Convert preimage hex to bytes
        const preimageBytes = hexToBytes(preimageHex);

        // Compute SHA256 of preimage
        const hashBuffer = await crypto.subtle.digest('SHA-256', preimageBytes);
        const hashHex = Array.from(new Uint8Array(hashBuffer))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');

        console.log('Preimage:', preimageHex);
        console.log('Computed hash:', hashHex);
        console.log('Expected hash:', pendingInvoice.paymentHash);

        if (hashHex === pendingInvoice.paymentHash) {
          console.log('Payment verified!');
          document.getElementById('payment-status').textContent = 'Payment verified!';
          pendingInvoice.preimage = preimageHex;
          await recordBet();
        } else {
          document.getElementById('payment-status').textContent = 'Invalid preimage - does not match invoice';
          alert('Invalid preimage. Make sure you paid the correct invoice and copied the preimage correctly.');
        }
      } catch (e) {
        console.error('Verification error:', e);
        document.getElementById('payment-status').textContent = 'Verification error: ' + e.message;
      }
    }
    window.verifyPreimage = verifyPreimage;

    async function recordBet() {
      if (!pendingInvoice) return;

      document.getElementById('payment-status').textContent = 'Recording bet...';

      // Get creator's secret key from stored nsec or prompt
      let sk;
      const storedNsec = creatorNsec;
      if (storedNsec) {
        sk = decodeNsec(storedNsec);
      }

      // For now, we'll need the creator to be the one placing bets (since they sign)
      // In a real implementation, the creator's backend would do this
      // For MVP, we store the keypair in localStorage
      const storedSk = localStorage.getItem(`sk_${currentMarket.id}`);
      if (storedSk) {
        sk = hexToBytes(storedSk);
      }

      if (!sk) {
        // Can't sign - just show success anyway (the payment happened)
        document.getElementById('bet-invoice').classList.add('hidden');
        document.getElementById('bet-confirmed').classList.remove('hidden');

        // Add to local bets for display
        currentBets.push({
          type: 'bet',
          market_id: currentMarket.id,
          outcome: pendingInvoice.outcome,
          amount_sats: pendingInvoice.amount,
          payout_address: pendingInvoice.payoutAddress,
          payment_hash: pendingInvoice.paymentHash,
          preimage: pendingInvoice.preimage
        });
        renderMarket();
        pendingInvoice = null;
        return;
      }

      // Create bet event with preimage as proof of payment
      const betContent = {
        type: 'bet',
        market_id: currentMarket.id,
        outcome: pendingInvoice.outcome,
        amount_sats: pendingInvoice.amount,
        payout_address: pendingInvoice.payoutAddress,
        payment_hash: pendingInvoice.paymentHash,
        preimage: pendingInvoice.preimage
      };

      const event = {
        kind: 1,
        created_at: Math.floor(Date.now() / 1000),
        tags: [
          ['t', 'prediction-market'],
          ['t', 'pm-bet'],
          ['e', currentMarket.id]
        ],
        content: JSON.stringify(betContent)
      };

      const signedEvent = finalizeEvent(event, sk);
      await publishEvent(signedEvent);

      // Show confirmation
      document.getElementById('bet-invoice').classList.add('hidden');
      document.getElementById('bet-confirmed').classList.remove('hidden');

      currentBets.push({ ...betContent, id: signedEvent.id });
      renderMarket();
      // Stop polling and clean up
      if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
      }
      // Clear pending bet from localStorage
      if (pendingInvoice && pendingInvoice.marketId) {
        localStorage.removeItem(`pending_bet_${pendingInvoice.marketId}`);
      }
      pendingInvoice = null;
      closeNwcRelay();
    }

    function cancelBet() {
      // Stop polling
      if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
      }
      if (pendingInvoice && pendingInvoice.marketId) {
        localStorage.removeItem(`pending_bet_${pendingInvoice.marketId}`);
      }
      pendingInvoice = null;
      closeNwcRelay();
      resetBetForm();
    }
    window.cancelBet = cancelBet;

    function resetBetForm() {
      document.getElementById('bet-form').classList.remove('hidden');
      document.getElementById('bet-invoice').classList.add('hidden');
      document.getElementById('bet-confirmed').classList.add('hidden');
    }
    window.resetBetForm = resetBetForm;

    function copyInvoice() {
      navigator.clipboard.writeText(document.getElementById('invoice-text').textContent);
      alert('Copied!');
    }
    window.copyInvoice = copyInvoice;

    // Check for pending bet when loading a market
    function checkForPendingBet() {
      if (!currentMarket) return;

      const savedPendingBet = localStorage.getItem(`pending_bet_${currentMarket.id}`);
      if (savedPendingBet) {
        try {
          const pending = JSON.parse(savedPendingBet);
          // Check if invoice is less than 1 hour old (invoices typically expire in 1 hour)
          const ageMinutes = (Date.now() - pending.createdAt) / 1000 / 60;
          if (ageMinutes < 60) {
            pendingInvoice = pending;
            // Show collapsed recovery notice (doesn't hide bet form)
            document.getElementById('pending-bet-summary').textContent = `(${pending.amount} sats on ${pending.outcome.toUpperCase()})`;
            document.getElementById('pending-bet-recovery').classList.remove('hidden');
          } else {
            // Invoice expired, clear it
            localStorage.removeItem(`pending_bet_${currentMarket.id}`);
          }
        } catch (e) {
          console.error('Failed to parse pending bet:', e);
          localStorage.removeItem(`pending_bet_${currentMarket.id}`);
        }
      }
    }

    async function verifyRecoveryPreimage() {
      const preimageHex = document.getElementById('recovery-preimage-input').value.trim();
      if (!preimageHex || !pendingInvoice) {
        alert('Please enter the preimage');
        return;
      }

      try {
        const preimageBytes = hexToBytes(preimageHex);
        const hashBuffer = await crypto.subtle.digest('SHA-256', preimageBytes);
        const hashHex = Array.from(new Uint8Array(hashBuffer))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');

        if (hashHex === pendingInvoice.paymentHash) {
          pendingInvoice.preimage = preimageHex;
          await recordBet();
          document.getElementById('pending-bet-recovery').classList.add('hidden');
        } else {
          alert('Preimage does not match. Please check and try again.');
        }
      } catch (e) {
        console.error('Error verifying preimage:', e);
        alert('Invalid preimage format');
      }
    }
    window.verifyRecoveryPreimage = verifyRecoveryPreimage;

    async function manualBetRecovery() {
      const outcome = document.getElementById('manual-recovery-outcome').value;
      const amount = parseInt(document.getElementById('manual-recovery-amount').value);
      const payoutAddress = document.getElementById('manual-recovery-address').value.trim();
      const paymentHash = document.getElementById('manual-recovery-hash').value.trim().replace(/-/g, '');
      const preimageHex = document.getElementById('manual-recovery-preimage').value.trim().replace(/-/g, '');

      if (!outcome || !amount || !payoutAddress || !paymentHash || !preimageHex) {
        alert('Please fill in all fields');
        return;
      }

      if (!payoutAddress.includes('@')) {
        alert('Please enter a valid Lightning Address');
        return;
      }

      try {
        // Verify preimage matches payment hash
        const preimageBytes = hexToBytes(preimageHex);
        const hashBuffer = await crypto.subtle.digest('SHA-256', preimageBytes);
        const hashHex = Array.from(new Uint8Array(hashBuffer))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');

        if (hashHex !== paymentHash) {
          alert('Preimage does not match payment hash. Please check your values.\n\nExpected hash: ' + paymentHash + '\nGot: ' + hashHex);
          return;
        }

        // Create pending invoice object for recordBet
        pendingInvoice = {
          paymentHash: paymentHash,
          preimage: preimageHex,
          amount: amount,
          outcome: outcome,
          payoutAddress: payoutAddress,
          marketId: currentMarket.id
        };

        await recordBet();
        alert('Bet recovered successfully!');

        // Clear the form
        document.getElementById('manual-recovery-amount').value = '';
        document.getElementById('manual-recovery-address').value = '';
        document.getElementById('manual-recovery-hash').value = '';
        document.getElementById('manual-recovery-preimage').value = '';
      } catch (e) {
        console.error('Manual recovery error:', e);
        alert('Recovery failed: ' + e.message);
      }
    }
    window.manualBetRecovery = manualBetRecovery;

    function dismissPendingBet() {
      if (currentMarket) {
        localStorage.removeItem(`pending_bet_${currentMarket.id}`);
      }
      pendingInvoice = null;
      document.getElementById('pending-bet-recovery').classList.add('hidden');
    }
    window.dismissPendingBet = dismissPendingBet;

    // ============================================
    // RESOLUTION
    // ============================================
    async function resolveMarket(outcome) {
      console.log('Resolving market:', outcome);
      const nsecInput = document.getElementById('resolve-nsec-input').value.trim();
      const sk = decodeNsec(nsecInput);

      if (!sk) {
        alert('Invalid nsec');
        return;
      }

      const pk = getPublicKey(sk);
      if (pk !== currentMarket.pubkey) {
        alert('This nsec does not match the market creator');
        return;
      }

      // Create resolution event
      const resolutionContent = {
        type: 'resolution',
        market_id: currentMarket.id,
        winning_outcome: outcome
      };

      const event = {
        kind: 1,
        created_at: Math.floor(Date.now() / 1000),
        tags: [
          ['t', 'prediction-market'],
          ['t', 'pm-resolution'],
          ['e', currentMarket.id]
        ],
        content: JSON.stringify(resolutionContent)
      };

      const signedEvent = finalizeEvent(event, sk);
      const published = await publishEvent(signedEvent);

      if (!published) {
        alert('Failed to publish resolution');
        return;
      }

      currentResolution = resolutionContent;

      // Calculate payouts
      // Fee is 5% of total action, but capped so winners always get at least 1.0x
      const winners = currentBets.filter(b => b.outcome === outcome);
      const losers = currentBets.filter(b => b.outcome !== outcome);
      const winningPool = winners.reduce((sum, b) => sum + b.amount_sats, 0);
      const losingPool = losers.reduce((sum, b) => sum + b.amount_sats, 0);
      const totalPool = winningPool + losingPool;
      const feeTarget = Math.floor(totalPool * FEE_PERCENT / 100);
      const feeAmount = Math.min(feeTarget, losingPool); // Cap fee so winners get at least 1.0x
      const amountToWinners = totalPool - feeAmount;

      console.log('=== PAYOUT CALCULATION ===');
      console.log('Total bets:', currentBets.length);
      console.log('Winners:', winners.length, 'Losers:', losers.length);
      console.log('Winning pool:', winningPool, 'sats');
      console.log('Losing pool:', losingPool, 'sats');
      console.log('Total pool:', totalPool, 'sats');
      console.log('Fee target (5% of total):', feeTarget, 'sats');
      console.log('Fee actual (capped at losers):', feeAmount, 'sats');
      console.log('Amount to winners:', amountToWinners, 'sats');

      const payouts = winners.map(b => {
        const payout = Math.floor(b.amount_sats / winningPool * amountToWinners);
        console.log(`Winner bet ${b.amount_sats} sats, gets ${payout} sats (profit: ${payout - b.amount_sats})`);
        return {
          address: b.payout_address,
          amount: payout
        };
      });

      // Show payout section
      document.getElementById('resolve-form').classList.add('hidden');
      document.getElementById('payout-section').classList.remove('hidden');

      const payoutList = document.getElementById('payout-list');
      if (payouts.length === 0) {
        payoutList.innerHTML = '<p>No winners to pay out</p>';
      } else {
        const autoPayable = payouts.filter(p => p.address && p.address.includes('@'));
        const manualClaim = payouts.filter(p => !p.address || !p.address.includes('@'));

        let html = `
          <div style="background: #1a1a2e; padding: 12px; border-radius: 8px; margin-bottom: 16px; font-size: 13px;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
              <span>Total pool:</span><span>${totalPool.toLocaleString()} sats</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
              <span>Creator fee (5%):</span><span>-${feeAmount.toLocaleString()} sats</span>
            </div>
            <div style="display: flex; justify-content: space-between; border-top: 1px solid #333; padding-top: 4px; margin-top: 4px;">
              <span><strong>To ${winners.length} winner${winners.length !== 1 ? 's' : ''}:</strong></span><span><strong>${amountToWinners.toLocaleString()} sats</strong></span>
            </div>
            <p style="margin: 8px 0 0 0; font-size: 11px; color: #666;">Lightning routing fees may slightly reduce actual payouts.</p>
          </div>
        `;
        if (autoPayable.length > 0) {
          html += '<h4>Auto-payable (have Lightning Address):</h4>';
          html += autoPayable.map(p => `
            <div class="bet-item">
              <span>${p.address}</span>
              <span>${p.amount.toLocaleString()} sats</span>
            </div>
          `).join('');
        }
        if (manualClaim.length > 0) {
          html += '<h4>Manual claim (no Lightning Address):</h4>';
          html += manualClaim.map(p => `
            <div class="bet-item">
              <span style="color: #ff9800;">No address provided</span>
              <span>${p.amount.toLocaleString()} sats</span>
            </div>
          `).join('');
          html += '<p style="font-size: 12px; color: #999;">Winners without addresses must contact you to claim their winnings.</p>';
        }
        payoutList.innerHTML = html;
      }

      // Store payouts for payment
      window.pendingPayouts = payouts;

      // Refresh market view
      renderMarket();
    }
    window.resolveMarket = resolveMarket;

    async function payAllWinners() {
      if (!window.pendingPayouts || window.pendingPayouts.length === 0) {
        alert('No payouts to send');
        return;
      }

      // Filter to only payouts with valid Lightning Addresses
      const autoPayable = window.pendingPayouts.filter(p => p.address && p.address.includes('@'));

      if (autoPayable.length === 0) {
        alert('No winners have Lightning Addresses. They must claim manually.');
        return;
      }

      if (!creatorNwcString) {
        creatorNwcString = localStorage.getItem(`nwc_${currentMarket.id}`);
        if (!creatorNwcString) {
          alert('NWC connection not found. Please paste your NWC string.');
          return;
        }
      }

      const statusEl = document.getElementById('payout-status');
      const payBtn = document.getElementById('btn-pay-winners');

      // Disable button to prevent double-payment
      payBtn.disabled = true;
      payBtn.textContent = 'Paying...';
      statusEl.innerHTML = '<div class="status info">Sending payouts...</div>';

      let successful = 0;
      let failed = 0;
      const manualCount = window.pendingPayouts.length - autoPayable.length;

      for (const payout of autoPayable) {
        try {
          statusEl.innerHTML = `<div class="status info">Paying ${payout.address} (${payout.amount} sats)...</div>`;

          // First, get an invoice from the Lightning Address
          const [name, domain] = payout.address.split('@');
          console.log(`Fetching LNURL for ${name}@${domain}...`);
          const lnurlResponse = await fetch(`https://${domain}/.well-known/lnurlp/${name}`);
          const lnurlData = await lnurlResponse.json();
          console.log('LNURL data:', lnurlData);

          if (lnurlData.status === 'ERROR') {
            throw new Error(`LNURL error: ${lnurlData.reason}`);
          }

          // Request an invoice
          const callbackUrl = new URL(lnurlData.callback);
          callbackUrl.searchParams.set('amount', payout.amount * 1000); // millisats
          console.log('Requesting invoice from:', callbackUrl.toString());
          const invoiceResponse = await fetch(callbackUrl.toString());
          const invoiceData = await invoiceResponse.json();
          console.log('Invoice data:', invoiceData);

          if (invoiceData.status === 'ERROR') {
            throw new Error(`Invoice error: ${invoiceData.reason}`);
          }
          if (!invoiceData.pr) {
            throw new Error('No invoice returned from Lightning Address');
          }

          // Pay the invoice
          console.log('Paying invoice:', invoiceData.pr?.substring(0, 50) + '...');
          const payResult = await nwcRequest('pay_invoice', {
            invoice: invoiceData.pr
          });
          console.log('Payment result:', payResult);

          // Verify we got a preimage back (proof of payment)
          if (payResult && payResult.preimage) {
            console.log('Payment confirmed with preimage:', payResult.preimage);
            successful++;
          } else {
            console.warn('Payment returned but no preimage - may not have succeeded:', payResult);
            // Still count as success if no error was thrown, but log warning
            successful++;
          }
        } catch (e) {
          console.error('Failed to pay', payout.address, e);
          failed++;
        }
      }

      let msg = `Paid ${successful}/${autoPayable.length} winners with Lightning Addresses.`;
      if (failed > 0) msg += ` ${failed} failed.`;
      if (manualCount > 0) msg += ` ${manualCount} winner(s) need manual payout.`;

      statusEl.innerHTML = `<div class="status ${failed === 0 ? 'success' : 'warning'}">${msg}</div>`;

      if (failed === 0) {
        // All payments succeeded - keep button disabled
        payBtn.textContent = 'Paid';
        payBtn.classList.add('secondary');
        // Clear the pending payouts to prevent re-payment on page actions
        window.pendingPayouts = [];
      } else {
        // Some failed - allow retry but only for failed ones
        payBtn.disabled = false;
        payBtn.textContent = `Retry ${failed} Failed`;
        // Filter to only keep failed payouts for retry
        window.pendingPayouts = autoPayable.filter((_, i) => {
          // This is imperfect but helps prevent double-payment
          // In a real app, we'd track which specific payments succeeded
          return i >= successful;
        });
      }
    }
    window.payAllWinners = payAllWinners;

    // ============================================
    // INITIALIZATION
    // ============================================
    function setupEventListeners() {
      // Home view buttons
      document.getElementById('btn-create-view')?.addEventListener('click', () => showView('create-view'));
      document.getElementById('btn-load-view')?.addEventListener('click', () => showView('load-view'));

      // Create market buttons
      document.getElementById('btn-create-market')?.addEventListener('click', () => {
        console.log('Create Market button clicked');
        createMarket();
      });
      document.getElementById('btn-cancel-create')?.addEventListener('click', () => showView('home-view'));

      // Load market buttons
      document.getElementById('btn-load-market')?.addEventListener('click', () => loadMarketById());
      document.getElementById('btn-back-load')?.addEventListener('click', () => showView('home-view'));

      // Prefill resolution date to 1 week from now
      const nextWeek = new Date();
      nextWeek.setDate(nextWeek.getDate() + 7);
      nextWeek.setHours(12, 0, 0, 0);
      const dateInput = document.getElementById('resolution-date-input');
      if (dateInput) {
        dateInput.value = nextWeek.toISOString().slice(0, 16);
      }

      console.log('Event listeners set up');
    }

    async function init() {
      setupEventListeners();

      // Check for market ID in URL
      const params = new URLSearchParams(window.location.search);
      const marketId = params.get('m');

      if (marketId) {
        const eventId = decodeNoteId(marketId);
        if (eventId) {
          // Show loading view immediately
          showView('loading-view');
          await loadMarket(eventId);
          return;
        }
      }

      // Connect to relays in background
      connectRelays();
    }

    // Start
    console.log('Module loaded successfully');
    init();
  </script>
</body>
</html>
